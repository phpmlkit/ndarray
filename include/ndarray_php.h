/* NDArray PHP - Auto-generated C header
 * Do not edit manually. Generated by cbindgen.
 */

#ifndef NDARRAY_PHP_H
#define NDARRAY_PHP_H

/* Warning: this file is auto-generated by cbindgen. Do not modify. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#define SUCCESS 0

#define ERR_GENERIC 1

#define ERR_SHAPE 2

#define ERR_DTYPE 3

#define ERR_ALLOC 4

#define ERR_PANIC 5

#define ERR_INDEX 6

#define ERR_MATH 7

/**
 * Opaque pointer type for FFI.
 *
 * PHP holds this pointer and passes it back to Rust for operations.
 * The actual NDArrayWrapper is stored behind this pointer.
 */
typedef struct NdArrayHandle {
  uint8_t _private[0];
} NdArrayHandle;

/**
 * Metadata describing a view into an array.
 *
 * This struct bundles all the metadata needed to describe a view - offset, shape, strides, and ndim.
 */
typedef struct ViewMetadata {
  /**
   * Offset into the underlying data buffer (in elements, not bytes)
   */
  uintptr_t offset;
  /**
   * Pointer to shape dimensions array
   */
  const uintptr_t *shape;
  /**
   * Pointer to strides array (in elements, not bytes)
   */
  const uintptr_t *strides;
  /**
   * Number of dimensions
   */
  uintptr_t ndim;
} ViewMetadata;

/**
 * Get the item size for a dtype. Returns 0 for invalid dtype values.
 */
uintptr_t dtype_item_size(uint8_t dtype);

/**
 * Check if a dtype value is valid.
 */
bool dtype_is_valid(uint8_t dtype);

/**
 * Check if a dtype is a signed integer.
 */
bool dtype_is_signed(uint8_t dtype);

/**
 * Check if a dtype is an unsigned integer.
 */
bool dtype_is_unsigned(uint8_t dtype);

/**
 * Check if a dtype is an integer type.
 */
bool dtype_is_integer(uint8_t dtype);

/**
 * Check if a dtype is a floating-point type.
 */
bool dtype_is_float(uint8_t dtype);

/**
 * Check if a dtype is a boolean type.
 */
bool dtype_is_bool(uint8_t dtype);

/**
 * Get the promoted dtype when combining two dtypes.
 * Returns 255 (invalid) if either dtype is invalid.
 */
uint8_t dtype_promote(uint8_t a, uint8_t b);

/**
 * Get the last error message.
 *
 * Writes the message to `buf` up to `len` bytes.
 * Returns the actual length of the message.
 */
uintptr_t ndarray_get_last_error(char *buf, uintptr_t len);

/**
 * Optimized addition with proper broadcasting support.
 *
 * Uses extract_view_as_* to convert inputs to the promoted dtype,
 * then performs addition with ndarray's native broadcasting.
 */
int32_t ndarray_add(const struct NdArrayHandle *a,
                    const struct ViewMetadata *a_meta,
                    const struct NdArrayHandle *b,
                    const struct ViewMetadata *b_meta,
                    struct NdArrayHandle **out,
                    uint8_t *out_dtype_ptr,
                    uintptr_t *out_ndim,
                    uintptr_t *out_shape,
                    uintptr_t max_ndim);

/**
 * Add scalar to array.
 */
int32_t ndarray_add_scalar(const struct NdArrayHandle *a,
                           const struct ViewMetadata *a_meta,
                           double scalar,
                           struct NdArrayHandle **out,
                           uint8_t *out_dtype,
                           uintptr_t *out_ndim,
                           uintptr_t *out_shape,
                           uintptr_t max_ndim);

/**
 * Optimized division with proper broadcasting support.
 */
int32_t ndarray_div(const struct NdArrayHandle *a,
                    const struct ViewMetadata *a_meta,
                    const struct NdArrayHandle *b,
                    const struct ViewMetadata *b_meta,
                    struct NdArrayHandle **out,
                    uint8_t *out_dtype_ptr,
                    uintptr_t *out_ndim,
                    uintptr_t *out_shape,
                    uintptr_t max_ndim);

/**
 * Divide array by scalar.
 */
int32_t ndarray_div_scalar(const struct NdArrayHandle *a,
                           const struct ViewMetadata *a_meta,
                           double scalar,
                           struct NdArrayHandle **out,
                           uint8_t *out_dtype,
                           uintptr_t *out_ndim,
                           uintptr_t *out_shape,
                           uintptr_t max_ndim);

/**
 * Optimized multiplication with proper broadcasting support.
 */
int32_t ndarray_mul(const struct NdArrayHandle *a,
                    const struct ViewMetadata *a_meta,
                    const struct NdArrayHandle *b,
                    const struct ViewMetadata *b_meta,
                    struct NdArrayHandle **out,
                    uint8_t *out_dtype_ptr,
                    uintptr_t *out_ndim,
                    uintptr_t *out_shape,
                    uintptr_t max_ndim);

/**
 * Multiply array by scalar.
 */
int32_t ndarray_mul_scalar(const struct NdArrayHandle *a,
                           const struct ViewMetadata *a_meta,
                           double scalar,
                           struct NdArrayHandle **out,
                           uint8_t *out_dtype,
                           uintptr_t *out_ndim,
                           uintptr_t *out_shape,
                           uintptr_t max_ndim);

/**
 * Optimized remainder with proper broadcasting support.
 */
int32_t ndarray_rem(const struct NdArrayHandle *a,
                    const struct ViewMetadata *a_meta,
                    const struct NdArrayHandle *b,
                    const struct ViewMetadata *b_meta,
                    struct NdArrayHandle **out,
                    uint8_t *out_dtype_ptr,
                    uintptr_t *out_ndim,
                    uintptr_t *out_shape,
                    uintptr_t max_ndim);

/**
 * Remainder with scalar.
 */
int32_t ndarray_rem_scalar(const struct NdArrayHandle *a,
                           const struct ViewMetadata *a_meta,
                           double scalar,
                           struct NdArrayHandle **out,
                           uint8_t *out_dtype,
                           uintptr_t *out_ndim,
                           uintptr_t *out_shape,
                           uintptr_t max_ndim);

/**
 * Optimized subtraction with proper broadcasting support.
 */
int32_t ndarray_sub(const struct NdArrayHandle *a,
                    const struct ViewMetadata *a_meta,
                    const struct NdArrayHandle *b,
                    const struct ViewMetadata *b_meta,
                    struct NdArrayHandle **out,
                    uint8_t *out_dtype_ptr,
                    uintptr_t *out_ndim,
                    uintptr_t *out_shape,
                    uintptr_t max_ndim);

/**
 * Subtract scalar from array.
 */
int32_t ndarray_sub_scalar(const struct NdArrayHandle *a,
                           const struct ViewMetadata *a_meta,
                           double scalar,
                           struct NdArrayHandle **out,
                           uint8_t *out_dtype,
                           uintptr_t *out_ndim,
                           uintptr_t *out_shape,
                           uintptr_t max_ndim);

/**
 * Create an NDArray from raw data with specified dtype.
 *
 * # Arguments
 * * `data` - Pointer to raw data (type depends on dtype)
 * * `len` - Number of elements
 * * `shape` - Pointer to shape array
 * * `ndim` - Number of dimensions
 * * `dtype` - Data type enum value
 * * `out_handle` - Output handle pointer
 */
int32_t ndarray_create(const void *data,
                       uintptr_t len,
                       const uintptr_t *shape,
                       uintptr_t ndim,
                       int32_t dtype,
                       struct NdArrayHandle **out_handle);

/**
 * Create a deep copy of an array view.
 */
int32_t ndarray_copy(const struct NdArrayHandle *handle,
                     const struct ViewMetadata *meta,
                     struct NdArrayHandle **out_handle);

/**
 * Get flattened data for an array view.
 *
 * # Arguments
 * * `handle` - Array handle
 * * `meta` - View metadata
 * * `out_data` - Pointer to output buffer (type depends on array dtype)
 * * `max_len` - Maximum number of elements to copy
 * * `out_len` - Output: actual number of elements in the view
 */
int32_t ndarray_get_data(const struct NdArrayHandle *handle,
                         const struct ViewMetadata *meta,
                         void *out_data,
                         uintptr_t max_len,
                         uintptr_t *out_len);

/**
 * Destroy an NDArray and free its memory.
 */
int32_t ndarray_free(struct NdArrayHandle *handle);

/**
 * Get the number of dimensions of an array.
 */
int32_t ndarray_ndim(const struct NdArrayHandle *handle, uintptr_t *out_ndim);

/**
 * Get the total number of elements in an array.
 */
int32_t ndarray_len(const struct NdArrayHandle *handle, uintptr_t *out_len);

/**
 * Get the dtype of an array.
 */
int32_t ndarray_dtype(const struct NdArrayHandle *handle, uint8_t *out_dtype);

/**
 * Get the shape of an array.
 *
 * Writes up to `max_ndim` dimensions to `out_shape` and returns the actual ndim in `out_ndim`.
 */
int32_t ndarray_shape(const struct NdArrayHandle *handle,
                      uintptr_t *out_shape,
                      uintptr_t max_ndim,
                      uintptr_t *out_ndim);

/**
 * Extract the scalar value from a 0-dimensional array or view.
 *
 * The array must have ndim == 0.
 * Writes the value to out_value; the caller must allocate a buffer of at least
 * 8 bytes and interpret based on the array's dtype.
 *
 * For bool: writes 0 or 1 to the first byte.
 * For numeric types: writes the native value (up to 8 bytes).
 */
int32_t ndarray_scalar(const struct NdArrayHandle *handle,
                       const struct ViewMetadata *meta,
                       void *out_value);

/**
 * Bitwise AND with proper broadcasting support.
 */
int32_t ndarray_bitand(const struct NdArrayHandle *a,
                       const struct ViewMetadata *a_meta,
                       const struct NdArrayHandle *b,
                       const struct ViewMetadata *b_meta,
                       struct NdArrayHandle **out,
                       uint8_t *out_dtype_ptr,
                       uintptr_t *out_ndim,
                       uintptr_t *out_shape,
                       uintptr_t max_ndim);

/**
 * Bitwise AND with scalar.
 */
int32_t ndarray_bitand_scalar(const struct NdArrayHandle *a,
                              const struct ViewMetadata *a_meta,
                              int64_t scalar,
                              struct NdArrayHandle **out,
                              uint8_t *out_dtype,
                              uintptr_t *out_ndim,
                              uintptr_t *out_shape,
                              uintptr_t max_ndim);

/**
 * Bitwise OR with proper broadcasting support.
 */
int32_t ndarray_bitor(const struct NdArrayHandle *a,
                      const struct ViewMetadata *a_meta,
                      const struct NdArrayHandle *b,
                      const struct ViewMetadata *b_meta,
                      struct NdArrayHandle **out,
                      uint8_t *out_dtype_ptr,
                      uintptr_t *out_ndim,
                      uintptr_t *out_shape,
                      uintptr_t max_ndim);

/**
 * Bitwise OR with scalar.
 */
int32_t ndarray_bitor_scalar(const struct NdArrayHandle *a,
                             const struct ViewMetadata *a_meta,
                             int64_t scalar,
                             struct NdArrayHandle **out,
                             uint8_t *out_dtype,
                             uintptr_t *out_ndim,
                             uintptr_t *out_shape,
                             uintptr_t max_ndim);

/**
 * Bitwise XOR with proper broadcasting support.
 */
int32_t ndarray_bitxor(const struct NdArrayHandle *a,
                       const struct ViewMetadata *a_meta,
                       const struct NdArrayHandle *b,
                       const struct ViewMetadata *b_meta,
                       struct NdArrayHandle **out,
                       uint8_t *out_dtype_ptr,
                       uintptr_t *out_ndim,
                       uintptr_t *out_shape,
                       uintptr_t max_ndim);

/**
 * Bitwise XOR with scalar.
 */
int32_t ndarray_bitxor_scalar(const struct NdArrayHandle *a,
                              const struct ViewMetadata *a_meta,
                              int64_t scalar,
                              struct NdArrayHandle **out,
                              uint8_t *out_dtype,
                              uintptr_t *out_ndim,
                              uintptr_t *out_shape,
                              uintptr_t max_ndim);

/**
 * Left shift with proper broadcasting support.
 */
int32_t ndarray_left_shift(const struct NdArrayHandle *a,
                           const struct ViewMetadata *a_meta,
                           const struct NdArrayHandle *b,
                           const struct ViewMetadata *b_meta,
                           struct NdArrayHandle **out,
                           uint8_t *out_dtype_ptr,
                           uintptr_t *out_ndim,
                           uintptr_t *out_shape,
                           uintptr_t max_ndim);

/**
 * Left shift with scalar.
 */
int32_t ndarray_left_shift_scalar(const struct NdArrayHandle *a,
                                  const struct ViewMetadata *a_meta,
                                  int64_t scalar,
                                  struct NdArrayHandle **out,
                                  uint8_t *out_dtype,
                                  uintptr_t *out_ndim,
                                  uintptr_t *out_shape,
                                  uintptr_t max_ndim);

/**
 * Right shift with proper broadcasting support.
 */
int32_t ndarray_right_shift(const struct NdArrayHandle *a,
                            const struct ViewMetadata *a_meta,
                            const struct NdArrayHandle *b,
                            const struct ViewMetadata *b_meta,
                            struct NdArrayHandle **out,
                            uint8_t *out_dtype_ptr,
                            uintptr_t *out_ndim,
                            uintptr_t *out_shape,
                            uintptr_t max_ndim);

/**
 * Right shift with scalar.
 */
int32_t ndarray_right_shift_scalar(const struct NdArrayHandle *a,
                                   const struct ViewMetadata *a_meta,
                                   int64_t scalar,
                                   struct NdArrayHandle **out,
                                   uint8_t *out_dtype,
                                   uintptr_t *out_ndim,
                                   uintptr_t *out_shape,
                                   uintptr_t max_ndim);

/**
 * Cast an NDArray to a different dtype.
 *
 */
int32_t ndarray_astype(const struct NdArrayHandle *handle,
                       const struct ViewMetadata *meta,
                       int32_t target_dtype,
                       struct NdArrayHandle **out);

/**
 * Element-wise equal comparison with broadcasting. Returns Bool array.
 */
int32_t ndarray_eq(const struct NdArrayHandle *a,
                   const struct ViewMetadata *a_meta,
                   const struct NdArrayHandle *b,
                   const struct ViewMetadata *b_meta,
                   struct NdArrayHandle **out,
                   uint8_t *out_dtype_ptr,
                   uintptr_t *out_ndim,
                   uintptr_t *out_shape,
                   uintptr_t max_ndim);

/**
 * Element-wise equal comparison with scalar. Returns Bool array.
 */
int32_t ndarray_eq_scalar(const struct NdArrayHandle *a,
                          const struct ViewMetadata *a_meta,
                          double scalar,
                          struct NdArrayHandle **out,
                          uint8_t *out_dtype,
                          uintptr_t *out_ndim,
                          uintptr_t *out_shape,
                          uintptr_t max_ndim);

/**
 * Element-wise greater-than comparison with broadcasting. Returns Bool array.
 */
int32_t ndarray_gt(const struct NdArrayHandle *a,
                   const struct ViewMetadata *a_meta,
                   const struct NdArrayHandle *b,
                   const struct ViewMetadata *b_meta,
                   struct NdArrayHandle **out,
                   uint8_t *out_dtype_ptr,
                   uintptr_t *out_ndim,
                   uintptr_t *out_shape,
                   uintptr_t max_ndim);

int32_t ndarray_gt_scalar(const struct NdArrayHandle *a,
                          const struct ViewMetadata *a_meta,
                          double scalar,
                          struct NdArrayHandle **out,
                          uint8_t *out_dtype,
                          uintptr_t *out_ndim,
                          uintptr_t *out_shape,
                          uintptr_t max_ndim);

/**
 * Element-wise greater-or-equal comparison with broadcasting. Returns Bool array.
 */
int32_t ndarray_gte(const struct NdArrayHandle *a,
                    const struct ViewMetadata *a_meta,
                    const struct NdArrayHandle *b,
                    const struct ViewMetadata *b_meta,
                    struct NdArrayHandle **out,
                    uint8_t *out_dtype_ptr,
                    uintptr_t *out_ndim,
                    uintptr_t *out_shape,
                    uintptr_t max_ndim);

int32_t ndarray_gte_scalar(const struct NdArrayHandle *a,
                           const struct ViewMetadata *a_meta,
                           double scalar,
                           struct NdArrayHandle **out,
                           uint8_t *out_dtype,
                           uintptr_t *out_ndim,
                           uintptr_t *out_shape,
                           uintptr_t max_ndim);

/**
 * Element-wise less-than comparison with broadcasting. Returns Bool array.
 */
int32_t ndarray_lt(const struct NdArrayHandle *a,
                   const struct ViewMetadata *a_meta,
                   const struct NdArrayHandle *b,
                   const struct ViewMetadata *b_meta,
                   struct NdArrayHandle **out,
                   uint8_t *out_dtype_ptr,
                   uintptr_t *out_ndim,
                   uintptr_t *out_shape,
                   uintptr_t max_ndim);

int32_t ndarray_lt_scalar(const struct NdArrayHandle *a,
                          const struct ViewMetadata *a_meta,
                          double scalar,
                          struct NdArrayHandle **out,
                          uint8_t *out_dtype,
                          uintptr_t *out_ndim,
                          uintptr_t *out_shape,
                          uintptr_t max_ndim);

/**
 * Element-wise less-or-equal comparison with broadcasting. Returns Bool array.
 */
int32_t ndarray_lte(const struct NdArrayHandle *a,
                    const struct ViewMetadata *a_meta,
                    const struct NdArrayHandle *b,
                    const struct ViewMetadata *b_meta,
                    struct NdArrayHandle **out,
                    uint8_t *out_dtype_ptr,
                    uintptr_t *out_ndim,
                    uintptr_t *out_shape,
                    uintptr_t max_ndim);

int32_t ndarray_lte_scalar(const struct NdArrayHandle *a,
                           const struct ViewMetadata *a_meta,
                           double scalar,
                           struct NdArrayHandle **out,
                           uint8_t *out_dtype,
                           uintptr_t *out_ndim,
                           uintptr_t *out_shape,
                           uintptr_t max_ndim);

/**
 * Element-wise not-equal comparison with broadcasting. Returns Bool array.
 */
int32_t ndarray_ne(const struct NdArrayHandle *a,
                   const struct ViewMetadata *a_meta,
                   const struct NdArrayHandle *b,
                   const struct ViewMetadata *b_meta,
                   struct NdArrayHandle **out,
                   uint8_t *out_dtype_ptr,
                   uintptr_t *out_ndim,
                   uintptr_t *out_shape,
                   uintptr_t max_ndim);

int32_t ndarray_ne_scalar(const struct NdArrayHandle *a,
                          const struct ViewMetadata *a_meta,
                          double scalar,
                          struct NdArrayHandle **out,
                          uint8_t *out_dtype,
                          uintptr_t *out_ndim,
                          uintptr_t *out_shape,
                          uintptr_t max_ndim);

/**
 * Create evenly spaced values within a given interval.
 *
 * For integer types, uses native arithmetic. For float types, manual calculation.
 * Returns error if step is zero.
 */
int32_t ndarray_arange(double start,
                       double stop,
                       double step,
                       uint8_t dtype,
                       struct NdArrayHandle **out_handle);

/**
 * Create a 2D identity matrix.
 */
int32_t ndarray_eye(uintptr_t n,
                    uintptr_t m,
                    intptr_t k,
                    uint8_t dtype,
                    struct NdArrayHandle **out_handle);

/**
 * Create an array filled with a specific value.
 */
int32_t ndarray_full(const uintptr_t *shape,
                     uintptr_t ndim,
                     const void *value,
                     uint8_t dtype,
                     struct NdArrayHandle **out_handle);

/**
 * Create numbers spaced geometrically from start to stop.
 *
 * Only supports Float32 and Float64 dtypes.
 * Returns error if start and stop have different signs or if either is zero.
 */
int32_t ndarray_geomspace(double start,
                          double stop,
                          uintptr_t num,
                          uint8_t dtype,
                          struct NdArrayHandle **out_handle);

/**
 * Create evenly spaced numbers over a specified interval.
 *
 * Only supports Float32 and Float64 dtypes.
 * The endpoint parameter controls whether stop is included.
 */
int32_t ndarray_linspace(double start,
                         double stop,
                         uintptr_t num,
                         bool endpoint,
                         uint8_t dtype,
                         struct NdArrayHandle **out_handle);

/**
 * Create numbers spaced evenly on a log scale.
 *
 * Only supports Float32 and Float64 dtypes.
 * Returns `base.powf(start)` to `base.powf(stop)` with `num` points.
 */
int32_t ndarray_logspace(double start,
                         double stop,
                         uintptr_t num,
                         double base,
                         uint8_t dtype,
                         struct NdArrayHandle **out_handle);

/**
 * Create an array of random values sampled from N(mean, std).
 *
 * Supports Float32 and Float64 only.
 */
int32_t ndarray_normal(double mean,
                       double std,
                       const uintptr_t *shape,
                       uintptr_t ndim,
                       uint8_t dtype,
                       bool has_seed,
                       uint64_t seed,
                       struct NdArrayHandle **out_handle);

/**
 * Create an array filled with ones.
 */
int32_t ndarray_ones(const uintptr_t *shape,
                     uintptr_t ndim,
                     uint8_t dtype,
                     struct NdArrayHandle **out_handle);

/**
 * Create an array of random values sampled from N(0, 1).
 *
 * Supports Float32 and Float64 only.
 */
int32_t ndarray_randn(const uintptr_t *shape,
                      uintptr_t ndim,
                      uint8_t dtype,
                      bool has_seed,
                      uint64_t seed,
                      struct NdArrayHandle **out_handle);

/**
 * Create an array of random values sampled uniformly from [0, 1).
 *
 * Supports Float32 and Float64 only.
 */
int32_t ndarray_random(const uintptr_t *shape,
                       uintptr_t ndim,
                       uint8_t dtype,
                       bool has_seed,
                       uint64_t seed,
                       struct NdArrayHandle **out_handle);

/**
 * Create an array of random integers sampled uniformly from [low, high).
 *
 * Supports signed and unsigned integer dtypes only.
 */
int32_t ndarray_random_int(int64_t low,
                           int64_t high,
                           const uintptr_t *shape,
                           uintptr_t ndim,
                           uint8_t dtype,
                           bool has_seed,
                           uint64_t seed,
                           struct NdArrayHandle **out_handle);

/**
 * Create an array of random values sampled uniformly from [low, high).
 *
 * Supports Float32 and Float64 only.
 */
int32_t ndarray_uniform(double low,
                        double high,
                        const uintptr_t *shape,
                        uintptr_t ndim,
                        uint8_t dtype,
                        bool has_seed,
                        uint64_t seed,
                        struct NdArrayHandle **out_handle);

/**
 * Create an array filled with zeros.
 */
int32_t ndarray_zeros(const uintptr_t *shape,
                      uintptr_t ndim,
                      uint8_t dtype,
                      struct NdArrayHandle **out_handle);

/**
 * Assign values from source view to destination view.
 *
 * # Arguments
 * * `dst` - Destination array handle
 * * `dst_meta` - Destination view metadata
 * * `src` - Source array handle
 * * `src_meta` - Source view metadata
 */
int32_t ndarray_assign(const struct NdArrayHandle *dst,
                       const struct ViewMetadata *dst_meta,
                       const struct NdArrayHandle *src,
                       const struct ViewMetadata *src_meta);

/**
 * Fill a slice with a value.
 *
 * # Arguments
 * * `handle` - Array handle
 * * `meta` - View metadata
 * * `value` - Pointer to the fill value (type depends on array dtype)
 */
int32_t ndarray_fill(const struct NdArrayHandle *handle,
                     const struct ViewMetadata *meta,
                     const void *value);

/**
 * Get an element at the given flat index.
 *
 * # Arguments
 * * `handle` - Array handle
 * * `flat_index` - Flat index of the element
 * * `out_value` - Pointer to store the value (type depends on array dtype)
 *
 * The caller must ensure `out_value` points to the correct type for the array's dtype.
 */
int32_t ndarray_get_element(const struct NdArrayHandle *handle,
                            uintptr_t flat_index,
                            void *out_value);

/**
 * Put values by flattened logical indices. Returns a mutated copy.
 */
int32_t ndarray_put_flat(const struct NdArrayHandle *handle,
                         const struct ViewMetadata *meta,
                         const int64_t *indices,
                         uintptr_t indices_len,
                         const void *values,
                         uintptr_t values_len,
                         double scalar_value,
                         bool has_scalar,
                         struct NdArrayHandle **out_handle);

/**
 * Put values by per-position indices along a specific axis. Returns a mutated copy.
 */
int32_t ndarray_put_along_axis(const struct NdArrayHandle *handle,
                               const struct ViewMetadata *meta,
                               const struct NdArrayHandle *indices_handle,
                               const struct ViewMetadata *indices_meta,
                               int32_t axis,
                               const void *values,
                               uintptr_t values_len,
                               double scalar_value,
                               bool has_scalar,
                               struct NdArrayHandle **out_handle);

/**
 * Add updates into flattened indices and return a mutated copy.
 */
int32_t ndarray_scatter_add_flat(const struct NdArrayHandle *handle,
                                 const struct ViewMetadata *meta,
                                 const int64_t *indices,
                                 uintptr_t indices_len,
                                 const void *updates,
                                 uintptr_t updates_len,
                                 double scalar_update,
                                 bool has_scalar,
                                 struct NdArrayHandle **out_handle);

/**
 * Set an element at the given flat index.
 *
 * # Arguments
 * * `handle` - Array handle
 * * `flat_index` - Flat index of the element
 * * `value` - Pointer to the value (type depends on array dtype)
 *
 * The caller must ensure `value` points to the correct type for the array's dtype.
 */
int32_t ndarray_set_element(struct NdArrayHandle *handle, uintptr_t flat_index, const void *value);

/**
 * Gather values by flattened logical indices.
 */
int32_t ndarray_take_flat(const struct NdArrayHandle *handle,
                          const struct ViewMetadata *meta,
                          const int64_t *indices,
                          uintptr_t indices_len,
                          const uintptr_t *indices_shape,
                          uintptr_t indices_ndim,
                          struct NdArrayHandle **out_handle);

/**
 * Gather values using per-position indices along a specific axis.
 */
int32_t ndarray_take_along_axis(const struct NdArrayHandle *handle,
                                const struct ViewMetadata *meta,
                                const struct NdArrayHandle *indices_handle,
                                const struct ViewMetadata *indices_meta,
                                int32_t axis,
                                struct NdArrayHandle **out_handle);

/**
 * Select values from x and y depending on condition.
 */
int32_t ndarray_where(const struct NdArrayHandle *cond_handle,
                      const struct ViewMetadata *cond_meta,
                      const struct NdArrayHandle *x_handle,
                      const struct ViewMetadata *x_meta,
                      const struct NdArrayHandle *y_handle,
                      const struct ViewMetadata *y_meta,
                      struct NdArrayHandle **out_handle,
                      uint8_t *out_dtype_ptr,
                      uintptr_t *out_ndim,
                      uintptr_t *out_shape,
                      uintptr_t max_ndim);

/**
 * Extract diagonal elements.
 */
int32_t ndarray_diagonal(const struct NdArrayHandle *handle,
                         const struct ViewMetadata *meta,
                         struct NdArrayHandle **out_handle,
                         uint8_t *out_dtype,
                         uintptr_t *out_ndim,
                         uintptr_t *out_shape,
                         uintptr_t max_ndim);

/**
 * Compute dot product of two arrays with full view support.
 *
 * Works directly on views without converting to Vec first.
 */
int32_t ndarray_dot(const struct NdArrayHandle *a,
                    const struct ViewMetadata *a_meta,
                    const struct NdArrayHandle *b,
                    const struct ViewMetadata *b_meta,
                    struct NdArrayHandle **out_handle,
                    uint8_t *out_dtype_ptr,
                    uintptr_t *out_ndim,
                    uintptr_t *out_shape,
                    uintptr_t max_ndim);

/**
 * Matrix multiplication with full view support.
 *
 * Accepts ViewMetadata for both arrays to properly handle views.
 */
int32_t ndarray_matmul(const struct NdArrayHandle *a,
                       const struct ViewMetadata *a_meta,
                       const struct NdArrayHandle *b,
                       const struct ViewMetadata *b_meta,
                       struct NdArrayHandle **out_handle,
                       uint8_t *out_dtype_ptr,
                       uintptr_t *out_ndim,
                       uintptr_t *out_shape,
                       uintptr_t max_ndim);

/**
 * Compute scalar norm (axis=None).
 */
int32_t ndarray_norm(const struct NdArrayHandle *handle,
                     const struct ViewMetadata *meta,
                     int32_t ord,
                     void *out_value,
                     uint8_t *out_dtype);

/**
 * Compute norm along axis.
 */
int32_t ndarray_norm_axis(const struct NdArrayHandle *handle,
                          const struct ViewMetadata *meta,
                          int32_t axis,
                          bool keepdims,
                          int32_t ord,
                          struct NdArrayHandle **out_handle);

/**
 * Compute trace (sum of diagonal elements).
 */
int32_t ndarray_trace(const struct NdArrayHandle *handle,
                      const struct ViewMetadata *meta,
                      struct NdArrayHandle **out_handle,
                      uint8_t *out_dtype,
                      uintptr_t *out_ndim,
                      uintptr_t *out_shape,
                      uintptr_t max_ndim);

/**
 * Compute cube root element-wise using ndarray's cbrt() method.
 */
int32_t ndarray_cbrt(const struct NdArrayHandle *a,
                     const struct ViewMetadata *meta,
                     struct NdArrayHandle **out,
                     uint8_t *out_dtype,
                     uintptr_t *out_ndim,
                     uintptr_t *out_shape,
                     uintptr_t max_ndim);

/**
 * Compute exponential element-wise using ndarray's exp() method.
 */
int32_t ndarray_exp(const struct NdArrayHandle *a,
                    const struct ViewMetadata *meta,
                    struct NdArrayHandle **out,
                    uint8_t *out_dtype,
                    uintptr_t *out_ndim,
                    uintptr_t *out_shape,
                    uintptr_t max_ndim);

/**
 * Compute 2^x element-wise using ndarray's exp2() method.
 */
int32_t ndarray_exp2(const struct NdArrayHandle *a,
                     const struct ViewMetadata *meta,
                     struct NdArrayHandle **out,
                     uint8_t *out_dtype,
                     uintptr_t *out_ndim,
                     uintptr_t *out_shape,
                     uintptr_t max_ndim);

/**
 * Compute natural logarithm element-wise using ndarray's ln() method.
 *
 * This is an alias for log().
 */
int32_t ndarray_ln(const struct NdArrayHandle *a,
                   const struct ViewMetadata *meta,
                   struct NdArrayHandle **out,
                   uint8_t *out_dtype,
                   uintptr_t *out_ndim,
                   uintptr_t *out_shape,
                   uintptr_t max_ndim);

/**
 * Compute ln(1+x) element-wise using ndarray's ln_1p() method.
 *
 * More accurate than computing ln(1+x) directly for small x.
 */
int32_t ndarray_ln_1p(const struct NdArrayHandle *a,
                      const struct ViewMetadata *meta,
                      struct NdArrayHandle **out,
                      uint8_t *out_dtype,
                      uintptr_t *out_ndim,
                      uintptr_t *out_shape,
                      uintptr_t max_ndim);

/**
 * Compute natural logarithm element-wise using ndarray's ln() method.
 */
int32_t ndarray_log(const struct NdArrayHandle *a,
                    const struct ViewMetadata *meta,
                    struct NdArrayHandle **out,
                    uint8_t *out_dtype,
                    uintptr_t *out_ndim,
                    uintptr_t *out_shape,
                    uintptr_t max_ndim);

/**
 * Compute base-10 logarithm element-wise using ndarray's log10() method.
 */
int32_t ndarray_log10(const struct NdArrayHandle *a,
                      const struct ViewMetadata *meta,
                      struct NdArrayHandle **out,
                      uint8_t *out_dtype,
                      uintptr_t *out_ndim,
                      uintptr_t *out_shape,
                      uintptr_t max_ndim);

/**
 * Compute base-2 logarithm element-wise using ndarray's log2() method.
 */
int32_t ndarray_log2(const struct NdArrayHandle *a,
                     const struct ViewMetadata *meta,
                     struct NdArrayHandle **out,
                     uint8_t *out_dtype,
                     uintptr_t *out_ndim,
                     uintptr_t *out_shape,
                     uintptr_t max_ndim);

/**
 * Compute square root element-wise using ndarray's sqrt() method.
 */
int32_t ndarray_sqrt(const struct NdArrayHandle *a,
                     const struct ViewMetadata *meta,
                     struct NdArrayHandle **out,
                     uint8_t *out_dtype,
                     uintptr_t *out_ndim,
                     uintptr_t *out_shape,
                     uintptr_t max_ndim);

/**
 * Compute arc cosine element-wise using ndarray's acos() method.
 */
int32_t ndarray_acos(const struct NdArrayHandle *a,
                     const struct ViewMetadata *meta,
                     struct NdArrayHandle **out,
                     uint8_t *out_dtype,
                     uintptr_t *out_ndim,
                     uintptr_t *out_shape,
                     uintptr_t max_ndim);

/**
 * Compute arc sine element-wise using ndarray's asin() method.
 */
int32_t ndarray_asin(const struct NdArrayHandle *a,
                     const struct ViewMetadata *meta,
                     struct NdArrayHandle **out,
                     uint8_t *out_dtype,
                     uintptr_t *out_ndim,
                     uintptr_t *out_shape,
                     uintptr_t max_ndim);

/**
 * Compute arc tangent element-wise using ndarray's atan() method.
 */
int32_t ndarray_atan(const struct NdArrayHandle *a,
                     const struct ViewMetadata *meta,
                     struct NdArrayHandle **out,
                     uint8_t *out_dtype,
                     uintptr_t *out_ndim,
                     uintptr_t *out_shape,
                     uintptr_t max_ndim);

/**
 * Compute cosine element-wise using ndarray's cos() method.
 */
int32_t ndarray_cos(const struct NdArrayHandle *a,
                    const struct ViewMetadata *meta,
                    struct NdArrayHandle **out,
                    uint8_t *out_dtype,
                    uintptr_t *out_ndim,
                    uintptr_t *out_shape,
                    uintptr_t max_ndim);

/**
 * Compute hyperbolic cosine element-wise using ndarray's cosh() method.
 */
int32_t ndarray_cosh(const struct NdArrayHandle *a,
                     const struct ViewMetadata *meta,
                     struct NdArrayHandle **out,
                     uint8_t *out_dtype,
                     uintptr_t *out_ndim,
                     uintptr_t *out_shape,
                     uintptr_t max_ndim);

/**
 * Compute sine element-wise using ndarray's sin() method.
 */
int32_t ndarray_sin(const struct NdArrayHandle *a,
                    const struct ViewMetadata *meta,
                    struct NdArrayHandle **out,
                    uint8_t *out_dtype,
                    uintptr_t *out_ndim,
                    uintptr_t *out_shape,
                    uintptr_t max_ndim);

/**
 * Compute hyperbolic sine element-wise using ndarray's sinh() method.
 */
int32_t ndarray_sinh(const struct NdArrayHandle *a,
                     const struct ViewMetadata *meta,
                     struct NdArrayHandle **out,
                     uint8_t *out_dtype,
                     uintptr_t *out_ndim,
                     uintptr_t *out_shape,
                     uintptr_t max_ndim);

/**
 * Compute tangent element-wise using ndarray's tan() method.
 */
int32_t ndarray_tan(const struct NdArrayHandle *a,
                    const struct ViewMetadata *meta,
                    struct NdArrayHandle **out,
                    uint8_t *out_dtype,
                    uintptr_t *out_ndim,
                    uintptr_t *out_shape,
                    uintptr_t max_ndim);

/**
 * Compute hyperbolic tangent element-wise using ndarray's tanh() method.
 */
int32_t ndarray_tanh(const struct NdArrayHandle *a,
                     const struct ViewMetadata *meta,
                     struct NdArrayHandle **out,
                     uint8_t *out_dtype,
                     uintptr_t *out_ndim,
                     uintptr_t *out_shape,
                     uintptr_t max_ndim);

/**
 * Convert radians to degrees element-wise using ndarray's to_degrees() method.
 */
int32_t ndarray_to_degrees(const struct NdArrayHandle *a,
                           const struct ViewMetadata *meta,
                           struct NdArrayHandle **out,
                           uint8_t *out_dtype,
                           uintptr_t *out_ndim,
                           uintptr_t *out_shape,
                           uintptr_t max_ndim);

/**
 * Convert degrees to radians element-wise using ndarray's to_radians() method.
 */
int32_t ndarray_to_radians(const struct NdArrayHandle *a,
                           const struct ViewMetadata *meta,
                           struct NdArrayHandle **out,
                           uint8_t *out_dtype,
                           uintptr_t *out_ndim,
                           uintptr_t *out_shape,
                           uintptr_t max_ndim);

/**
 * Compute hypot(a, b) = sqrt(a^2 + b^2) element-wise where b is a scalar.
 */
int32_t ndarray_hypot(const struct NdArrayHandle *a,
                      const struct ViewMetadata *meta,
                      double b,
                      struct NdArrayHandle **out,
                      uint8_t *out_dtype,
                      uintptr_t *out_ndim,
                      uintptr_t *out_shape,
                      uintptr_t max_ndim);

/**
 * Compute x^2 element-wise.
 */
int32_t ndarray_pow2(const struct NdArrayHandle *a,
                     const struct ViewMetadata *meta,
                     struct NdArrayHandle **out,
                     uint8_t *out_dtype,
                     uintptr_t *out_ndim,
                     uintptr_t *out_shape,
                     uintptr_t max_ndim);

/**
 * Compute x^y where y is a float, element-wise using ndarray's powf.
 */
int32_t ndarray_powf(const struct NdArrayHandle *a,
                     const struct ViewMetadata *meta,
                     double exp,
                     struct NdArrayHandle **out,
                     uint8_t *out_dtype,
                     uintptr_t *out_ndim,
                     uintptr_t *out_shape,
                     uintptr_t max_ndim);

/**
 * Compute x^n where n is an integer, element-wise using ndarray's powi.
 *
 * Generally faster than powf for integer exponents.
 */
int32_t ndarray_powi(const struct NdArrayHandle *a,
                     const struct ViewMetadata *meta,
                     int32_t exp,
                     struct NdArrayHandle **out,
                     uint8_t *out_dtype,
                     uintptr_t *out_ndim,
                     uintptr_t *out_shape,
                     uintptr_t max_ndim);

/**
 * Compute 1/x element-wise using ndarray's recip() method.
 */
int32_t ndarray_recip(const struct NdArrayHandle *a,
                      const struct ViewMetadata *meta,
                      struct NdArrayHandle **out,
                      uint8_t *out_dtype,
                      uintptr_t *out_ndim,
                      uintptr_t *out_shape,
                      uintptr_t max_ndim);

/**
 * Compute ceiling element-wise using ndarray's ceil() method.
 */
int32_t ndarray_ceil(const struct NdArrayHandle *a,
                     const struct ViewMetadata *meta,
                     struct NdArrayHandle **out,
                     uint8_t *out_dtype,
                     uintptr_t *out_ndim,
                     uintptr_t *out_shape,
                     uintptr_t max_ndim);

/**
 * Compute floor element-wise using ndarray's floor() method.
 */
int32_t ndarray_floor(const struct NdArrayHandle *a,
                      const struct ViewMetadata *meta,
                      struct NdArrayHandle **out,
                      uint8_t *out_dtype,
                      uintptr_t *out_ndim,
                      uintptr_t *out_shape,
                      uintptr_t max_ndim);

/**
 * Compute round element-wise using ndarray's round() method.
 */
int32_t ndarray_round(const struct NdArrayHandle *a,
                      const struct ViewMetadata *meta,
                      struct NdArrayHandle **out,
                      uint8_t *out_dtype,
                      uintptr_t *out_ndim,
                      uintptr_t *out_shape,
                      uintptr_t max_ndim);

/**
 * Compute absolute value element-wise using ndarray's abs().
 */
int32_t ndarray_abs(const struct NdArrayHandle *a,
                    const struct ViewMetadata *meta,
                    struct NdArrayHandle **out,
                    uint8_t *out_dtype,
                    uintptr_t *out_ndim,
                    uintptr_t *out_shape,
                    uintptr_t max_ndim);

/**
 * Compute negation element-wise using ndarray's neg() method.
 * Not supported for unsigned integers or bool.
 */
int32_t ndarray_neg(const struct NdArrayHandle *a,
                    const struct ViewMetadata *meta,
                    struct NdArrayHandle **out,
                    uint8_t *out_dtype,
                    uintptr_t *out_ndim,
                    uintptr_t *out_shape,
                    uintptr_t max_ndim);

/**
 * Compute sigmoid element-wise: 1 / (1 + exp(-x)).
 */
int32_t ndarray_sigmoid(const struct NdArrayHandle *a,
                        const struct ViewMetadata *meta,
                        struct NdArrayHandle **out,
                        uint8_t *out_dtype,
                        uintptr_t *out_ndim,
                        uintptr_t *out_shape,
                        uintptr_t max_ndim);

/**
 * Compute signum element-wise using ndarray's signum().
 */
int32_t ndarray_signum(const struct NdArrayHandle *a,
                       const struct ViewMetadata *meta,
                       struct NdArrayHandle **out,
                       uint8_t *out_dtype,
                       uintptr_t *out_ndim,
                       uintptr_t *out_shape,
                       uintptr_t max_ndim);

/**
 * Softmax along axis. Numerically stable: subtract max before exp.
 */
int32_t ndarray_softmax(const struct NdArrayHandle *handle,
                        const struct ViewMetadata *meta,
                        int32_t axis,
                        struct NdArrayHandle **out_handle,
                        uint8_t *out_dtype,
                        uintptr_t *out_ndim,
                        uintptr_t *out_shape,
                        uintptr_t max_ndim);

/**
 * Argmax along axis.
 */
int32_t ndarray_argmax_axis(const struct NdArrayHandle *handle,
                            const struct ViewMetadata *meta,
                            int32_t axis,
                            bool keepdims,
                            struct NdArrayHandle **out_handle,
                            uint8_t *out_dtype,
                            uintptr_t *out_ndim,
                            uintptr_t *out_shape,
                            uintptr_t max_ndim);

/**
 * Compute the index of the maximum element.
 * Returns Int64 index.
 */
int32_t ndarray_argmax(const struct NdArrayHandle *handle,
                       const struct ViewMetadata *meta,
                       void *out_value,
                       uint8_t *out_dtype);

/**
 * Argmin along axis.
 */
int32_t ndarray_argmin_axis(const struct NdArrayHandle *handle,
                            const struct ViewMetadata *meta,
                            int32_t axis,
                            bool keepdims,
                            struct NdArrayHandle **out_handle,
                            uint8_t *out_dtype,
                            uintptr_t *out_ndim,
                            uintptr_t *out_shape,
                            uintptr_t max_ndim);

/**
 * Compute the index of the minimum element.
 * Returns Int64 index.
 */
int32_t ndarray_argmin(const struct NdArrayHandle *handle,
                       const struct ViewMetadata *meta,
                       void *out_value,
                       uint8_t *out_dtype);

/**
 * Count occurrences of non-negative integer values in flattened input.
 */
int32_t ndarray_bincount(const struct NdArrayHandle *handle,
                         const struct ViewMetadata *meta,
                         uintptr_t minlength,
                         struct NdArrayHandle **out_handle,
                         uint8_t *out_dtype,
                         uintptr_t *out_ndim,
                         uintptr_t *out_shape,
                         uintptr_t max_ndim);

/**
 * Cumulative product over flattened array. Returns 1D array.
 */
int32_t ndarray_cumprod(const struct NdArrayHandle *handle,
                        const struct ViewMetadata *meta,
                        struct NdArrayHandle **out_handle,
                        uint8_t *out_dtype,
                        uintptr_t *out_ndim,
                        uintptr_t *out_shape,
                        uintptr_t max_ndim);

/**
 * Cumulative product along axis.
 */
int32_t ndarray_cumprod_axis(const struct NdArrayHandle *handle,
                             const struct ViewMetadata *meta,
                             int32_t axis,
                             struct NdArrayHandle **out_handle,
                             uint8_t *out_dtype,
                             uintptr_t *out_ndim,
                             uintptr_t *out_shape,
                             uintptr_t max_ndim);

/**
 * Cumulative sum over flattened array. Returns 1D array.
 */
int32_t ndarray_cumsum(const struct NdArrayHandle *handle,
                       const struct ViewMetadata *meta,
                       struct NdArrayHandle **out_handle,
                       uint8_t *out_dtype,
                       uintptr_t *out_ndim,
                       uintptr_t *out_shape,
                       uintptr_t max_ndim);

/**
 * Cumulative sum along axis.
 */
int32_t ndarray_cumsum_axis(const struct NdArrayHandle *handle,
                            const struct ViewMetadata *meta,
                            int32_t axis,
                            struct NdArrayHandle **out_handle,
                            uint8_t *out_dtype,
                            uintptr_t *out_ndim,
                            uintptr_t *out_shape,
                            uintptr_t max_ndim);

/**
 * Compute the mean of all elements in the array.
 *
 * Returns Float64 regardless of input dtype.
 */
int32_t ndarray_mean(const struct NdArrayHandle *handle,
                     const struct ViewMetadata *meta,
                     void *out_value,
                     uint8_t *out_dtype);

/**
 * Compute the mean along an axis.
 */
int32_t ndarray_mean_axis(const struct NdArrayHandle *handle,
                          const struct ViewMetadata *meta,
                          int32_t axis,
                          bool keepdims,
                          struct NdArrayHandle **out_handle,
                          uint8_t *out_dtype,
                          uintptr_t *out_ndim,
                          uintptr_t *out_shape,
                          uintptr_t max_ndim);

/**
 * Compute the maximum of all elements in the array.
 */
int32_t ndarray_max(const struct NdArrayHandle *handle,
                    const struct ViewMetadata *meta,
                    void *out_value,
                    uint8_t *out_dtype);

/**
 * Compute the maximum along an axis.
 */
int32_t ndarray_max_axis(const struct NdArrayHandle *handle,
                         const struct ViewMetadata *meta,
                         int32_t axis,
                         bool keepdims,
                         struct NdArrayHandle **out_handle,
                         uint8_t *out_dtype,
                         uintptr_t *out_ndim,
                         uintptr_t *out_shape,
                         uintptr_t max_ndim);

/**
 * Compute the minimum of all elements in the array.
 */
int32_t ndarray_min(const struct NdArrayHandle *handle,
                    const struct ViewMetadata *meta,
                    void *out_value,
                    uint8_t *out_dtype);

/**
 * Compute the minimum along an axis.
 */
int32_t ndarray_min_axis(const struct NdArrayHandle *handle,
                         const struct ViewMetadata *meta,
                         int32_t axis,
                         bool keepdims,
                         struct NdArrayHandle **out_handle,
                         uint8_t *out_dtype,
                         uintptr_t *out_ndim,
                         uintptr_t *out_shape,
                         uintptr_t max_ndim);

/**
 * Compute the product of all elements in the array.
 */
int32_t ndarray_product(const struct NdArrayHandle *handle,
                        const struct ViewMetadata *meta,
                        void *out_value,
                        uint8_t *out_dtype);

/**
 * Compute the product along an axis.
 */
int32_t ndarray_product_axis(const struct NdArrayHandle *handle,
                             const struct ViewMetadata *meta,
                             int32_t axis,
                             bool keepdims,
                             struct NdArrayHandle **out_handle,
                             uint8_t *out_dtype,
                             uintptr_t *out_ndim,
                             uintptr_t *out_shape,
                             uintptr_t max_ndim);

/**
 * Compute the variance of all elements in the array.
 */
int32_t ndarray_var(const struct NdArrayHandle *handle,
                    const struct ViewMetadata *meta,
                    double ddof,
                    void *out_value,
                    uint8_t *out_dtype);

/**
 * Compute the variance along an axis in the array.
 */
int32_t ndarray_var_axis(const struct NdArrayHandle *handle,
                         const struct ViewMetadata *meta,
                         int32_t axis,
                         bool keepdims,
                         double ddof,
                         struct NdArrayHandle **out_handle,
                         uint8_t *out_dtype,
                         uintptr_t *out_ndim,
                         uintptr_t *out_shape,
                         uintptr_t max_ndim);

/**
 * Compute the standard deviation of all elements in the array.
 */
int32_t ndarray_std(const struct NdArrayHandle *handle,
                    const struct ViewMetadata *meta,
                    double ddof,
                    void *out_value,
                    uint8_t *out_dtype);

/**
 * Compute the standard deviation along an axis in the array.
 */
int32_t ndarray_std_axis(const struct NdArrayHandle *handle,
                         const struct ViewMetadata *meta,
                         int32_t axis,
                         bool keepdims,
                         double ddof,
                         struct NdArrayHandle **out_handle,
                         uint8_t *out_dtype,
                         uintptr_t *out_ndim,
                         uintptr_t *out_shape,
                         uintptr_t max_ndim);

/**
 * Compute the sum of all elements in the array.
 */
int32_t ndarray_sum(const struct NdArrayHandle *handle,
                    const struct ViewMetadata *meta,
                    void *out_value,
                    uint8_t *out_dtype);

/**
 * Compute the sum along an axis.
 */
int32_t ndarray_sum_axis(const struct NdArrayHandle *handle,
                         const struct ViewMetadata *meta,
                         int32_t axis,
                         bool keepdims,
                         struct NdArrayHandle **out_handle,
                         uint8_t *out_dtype,
                         uintptr_t *out_ndim,
                         uintptr_t *out_shape,
                         uintptr_t max_ndim);

/**
 * Flatten array to 1D.
 */
int32_t ndarray_flatten(const struct NdArrayHandle *handle,
                        const struct ViewMetadata *meta,
                        struct NdArrayHandle **out_handle,
                        uint8_t *out_dtype,
                        uintptr_t *out_ndim,
                        uintptr_t *out_shape,
                        uintptr_t max_ndim);

/**
 * Ravel array to 1D.
 *
 * Similar to flatten but may return a view if the array is already contiguous.
 * For FFI simplicity, we always return a copy in the specified order.
 */
int32_t ndarray_ravel(const struct NdArrayHandle *handle,
                      const struct ViewMetadata *meta,
                      int32_t order,
                      struct NdArrayHandle **out_handle,
                      uint8_t *out_dtype,
                      uintptr_t *out_ndim,
                      uintptr_t *out_shape,
                      uintptr_t max_ndim);

/**
 * Insert new array axis at axis and return the result.
 *
 * The new axis always has length 1.
 * Panics if the axis is out of bounds.
 */
int32_t ndarray_insert_axis(const struct NdArrayHandle *handle,
                            const struct ViewMetadata *meta,
                            uintptr_t axis,
                            struct NdArrayHandle **out_handle,
                            uint8_t *out_dtype,
                            uintptr_t *out_ndim,
                            uintptr_t *out_shape,
                            uintptr_t max_ndim);

/**
 * Reverse the stride of axis and return in standard layout.
 *
 * Panics if the axis is out of bounds.
 */
int32_t ndarray_invert_axis(const struct NdArrayHandle *handle,
                            const struct ViewMetadata *meta,
                            uintptr_t axis,
                            struct NdArrayHandle **out_handle,
                            uint8_t *out_dtype,
                            uintptr_t *out_ndim,
                            uintptr_t *out_shape,
                            uintptr_t max_ndim);

/**
 * Merge in the axis take into into.
 *
 * Returns true iff the axes are now merged.
 * This method merges the axes if movement along the two original axes can be
 * equivalently represented as movement along one (merged) axis.
 */
int32_t ndarray_merge_axes(const struct NdArrayHandle *handle,
                           const struct ViewMetadata *meta,
                           uintptr_t take,
                           uintptr_t into,
                           struct NdArrayHandle **out_handle,
                           uint8_t *out_dtype,
                           uintptr_t *out_ndim,
                           uintptr_t *out_shape,
                           uintptr_t max_ndim);

/**
 * Pad an array with constant/symmetric/reflect mode.
 */
int32_t ndarray_pad(const struct NdArrayHandle *handle,
                    const struct ViewMetadata *meta,
                    const uintptr_t *pad_width,
                    int32_t mode,
                    const double *constant_values,
                    uintptr_t constant_values_len,
                    struct NdArrayHandle **out_handle,
                    uint8_t *out_dtype,
                    uintptr_t *out_ndim,
                    uintptr_t *out_shape,
                    uintptr_t max_ndim);

/**
 * Permute axes of the array and return in standard layout.
 *
 * The axes array specifies the new order of axes.
 * Panics if axes are invalid (out of bounds, missing, or duplicated).
 */
int32_t ndarray_permute_axes(const struct NdArrayHandle *handle,
                             const struct ViewMetadata *meta,
                             const uintptr_t *axes,
                             uintptr_t num_axes,
                             struct NdArrayHandle **out_handle,
                             uint8_t *out_dtype,
                             uintptr_t *out_ndim,
                             uintptr_t *out_shape,
                             uintptr_t max_ndim);

/**
 * Repeat elements of an array.
 */
int32_t ndarray_repeat(const struct NdArrayHandle *handle,
                       const struct ViewMetadata *meta,
                       const uintptr_t *repeats,
                       uintptr_t repeats_len,
                       int32_t axis,
                       struct NdArrayHandle **out_handle,
                       uint8_t *out_dtype,
                       uintptr_t *out_ndim,
                       uintptr_t *out_shape,
                       uintptr_t max_ndim);

/**
 * Reshape array to new shape.
 *
 * Uses ndarray's `to_shape` which returns a view if contiguous, otherwise copies.
 * Supports both RowMajor (C-style) and ColumnMajor (F-style) ordering.
 */
int32_t ndarray_reshape(const struct NdArrayHandle *handle,
                        const struct ViewMetadata *meta,
                        const uintptr_t *new_shape,
                        uintptr_t new_ndim,
                        int32_t order,
                        struct NdArrayHandle **out_handle);

/**
 * Remove axes of length 1 from the array.
 *
 * If `axes` is null and `num_axes` is 0, removes all length-1 axes.
 * Otherwise, removes only the specified axes.
 */
int32_t ndarray_squeeze(const struct NdArrayHandle *handle,
                        const struct ViewMetadata *meta,
                        const uintptr_t *axes,
                        uintptr_t num_axes,
                        struct NdArrayHandle **out_handle,
                        uint8_t *out_dtype,
                        uintptr_t *out_ndim,
                        uintptr_t *out_shape,
                        uintptr_t max_ndim);

/**
 * Swap two axes of the array.
 *
 * Returns a copy with data in standard C-contiguous layout.
 */
int32_t ndarray_swap_axes(const struct NdArrayHandle *handle,
                          const struct ViewMetadata *meta,
                          uintptr_t axis1,
                          uintptr_t axis2,
                          struct NdArrayHandle **out_handle,
                          uint8_t *out_dtype,
                          uintptr_t *out_ndim,
                          uintptr_t *out_shape,
                          uintptr_t max_ndim);

/**
 * Tile an array by repeating it.
 */
int32_t ndarray_tile(const struct NdArrayHandle *handle,
                     const struct ViewMetadata *meta,
                     const uintptr_t *reps,
                     uintptr_t reps_len,
                     struct NdArrayHandle **out_handle,
                     uint8_t *out_dtype,
                     uintptr_t *out_ndim,
                     uintptr_t *out_shape,
                     uintptr_t max_ndim);

/**
 * Transpose array (swap all axes).
 *
 * For a 2D array, this swaps rows and columns.
 * For nD arrays, reverses the order of all axes.
 */
int32_t ndarray_transpose(const struct NdArrayHandle *handle,
                          const struct ViewMetadata *meta,
                          struct NdArrayHandle **out_handle,
                          uint8_t *out_dtype,
                          uintptr_t *out_ndim,
                          uintptr_t *out_shape,
                          uintptr_t max_ndim);

/**
 * Compute the argsort along an axis in the array.
 */
int32_t ndarray_argsort_axis(const struct NdArrayHandle *handle,
                             const struct ViewMetadata *meta,
                             int32_t axis,
                             int32_t kind,
                             struct NdArrayHandle **out_handle,
                             uint8_t *out_dtype,
                             uintptr_t *out_ndim,
                             uintptr_t *out_shape,
                             uintptr_t max_ndim);

/**
 * Compute the argsort of the flattened array.
 */
int32_t ndarray_argsort_flat(const struct NdArrayHandle *handle,
                             const struct ViewMetadata *meta,
                             int32_t kind,
                             struct NdArrayHandle **out_handle,
                             uint8_t *out_dtype,
                             uintptr_t *out_ndim,
                             uintptr_t *out_shape,
                             uintptr_t max_ndim);

/**
 * Compute the sort along an axis in the array.
 */
int32_t ndarray_sort_axis(const struct NdArrayHandle *handle,
                          const struct ViewMetadata *meta,
                          int32_t axis,
                          int32_t kind,
                          struct NdArrayHandle **out_handle,
                          uint8_t *out_dtype,
                          uintptr_t *out_ndim,
                          uintptr_t *out_shape,
                          uintptr_t max_ndim);

/**
 * Compute the sort of the flattened array.
 */
int32_t ndarray_sort_flat(const struct NdArrayHandle *handle,
                          const struct ViewMetadata *meta,
                          int32_t kind,
                          struct NdArrayHandle **out_handle,
                          uint8_t *out_dtype,
                          uintptr_t *out_ndim,
                          uintptr_t *out_shape,
                          uintptr_t max_ndim);

/**
 * Compute the top-k values and indices along an axis in the array.
 */
int32_t ndarray_topk_axis(const struct NdArrayHandle *handle,
                          const struct ViewMetadata *meta,
                          int32_t axis,
                          uintptr_t k,
                          bool largest,
                          bool sorted,
                          int32_t kind,
                          struct NdArrayHandle **out_values,
                          struct NdArrayHandle **out_indices,
                          uintptr_t *out_shape,
                          uintptr_t max_ndim);

/**
 * Compute the top-k values and indices of the flattened array.
 */
int32_t ndarray_topk_flat(const struct NdArrayHandle *handle,
                          const struct ViewMetadata *meta,
                          uintptr_t k,
                          bool largest,
                          bool sorted,
                          int32_t kind,
                          struct NdArrayHandle **out_values,
                          struct NdArrayHandle **out_indices,
                          uintptr_t *out_shape);

/**
 * Clamp array values to [min, max] range.
 *
 * Similar to NumPy's clip function.
 * Returns error if min > max.
 */
int32_t ndarray_clamp(const struct NdArrayHandle *handle,
                      const struct ViewMetadata *meta,
                      double min_val,
                      double max_val,
                      struct NdArrayHandle **out_handle,
                      uint8_t *out_dtype,
                      uintptr_t *out_ndim,
                      uintptr_t *out_shape,
                      uintptr_t max_ndim);

/**
 * Concatenate N arrays along the given axis.
 *
 * handles: pointer to array of num_arrays handles
 * metas: pointer to array of num_arrays ViewMetadata pointers
 */
int32_t ndarray_concatenate(const struct NdArrayHandle *const *handles,
                            const struct ViewMetadata *const *metas,
                            uintptr_t num_arrays,
                            int32_t axis,
                            struct NdArrayHandle **out_handle,
                            uintptr_t *out_ndim,
                            uintptr_t *out_shape,
                            uintptr_t max_ndim);

/**
 * Split array along axis at the given indices.
 *
 * indices[i] is the start of part i+1 (exclusive end of part i).
 * Parts: [0..indices[0]), [indices[0]..indices[1]), ..., [indices[n-1]..len].
 * Output count = num_indices + 1.
 *
 * Writes to out_offsets (size num_indices+1), out_shapes and out_strides (size (num_indices+1)*ndim each).
 */
int32_t ndarray_split(const struct NdArrayHandle *_handle,
                      const struct ViewMetadata *meta,
                      int32_t axis,
                      const uintptr_t *indices,
                      uintptr_t num_indices,
                      uintptr_t *out_offsets,
                      uintptr_t *out_shapes,
                      uintptr_t *out_strides);

/**
 * Stack N arrays along a new axis.
 *
 * handles: pointer to array of num_arrays handles
 * metas: pointer to array of num_arrays ViewMetadata pointers
 */
int32_t ndarray_stack(const struct NdArrayHandle *const *handles,
                      const struct ViewMetadata *const *metas,
                      uintptr_t num_arrays,
                      int32_t axis,
                      struct NdArrayHandle **out_handle,
                      uintptr_t *out_ndim,
                      uintptr_t *out_shape,
                      uintptr_t max_ndim);

#endif /* NDARRAY_PHP_H */
