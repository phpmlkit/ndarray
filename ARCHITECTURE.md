# PHP NDArray Library - Technical Architecture

## Table of Contents
1. [Overview](#1-overview)
2. [Project Structure](#2-project-structure)
3. [FFI Architecture](#3-ffi-architecture)
4. [PHP API Surface](#4-php-api-surface)
5. [Rust Implementation](#5-rust-implementation)
6. [Memory Management Strategy](#6-memory-management-strategy)
7. [Build System](#7-build-system)
8. [Development Workflow](#8-development-workflow)
9. [Testing Strategy](#9-testing-strategy)
10. [Performance Optimization](#10-performance-optimization)

---

## 1. Overview

### 1.1 Architecture Principles

**Layered Design**:
```
┌─────────────────────────────────────────┐
│         PHP User Code                   │
├─────────────────────────────────────────┤
│    PHP API Layer (OOP Interface)        │
├─────────────────────────────────────────┤
│    FFI Bridge (C-compatible)            │
├─────────────────────────────────────────┤
│    Rust Core (ndarray + custom logic)   │
└─────────────────────────────────────────┘
```

**Design Goals**:
- Minimize FFI crossings by batching operations
- Keep PHP API idiomatic and object-oriented
- Handle all memory management in Rust
- Make BLAS optional, not required
- Ensure thread-safety across FFI boundary

### 1.2 Technology Stack

- **PHP**: 8.1+ (FFI extension required)
- **Rust**: Latest stable (1.75+)
- **Build**: Cargo, Composer
- **Testing**: PHPUnit, Rust's `cargo test`
- **Optional**: OpenBLAS, Intel MKL

---

## 2. Project Structure

```
phpndarray/
├── composer.json
├── phpunit.xml
├── README.md
├── LICENSE
│
├── src/                          # PHP source code
│   ├── NDArray.php              # Main NDArray class
│   ├── FFI/
│   │   ├── FFIInterface.php     # FFI singleton manager
│   │   └── Library.php          # Dynamic library loader
│   ├── Exceptions/
│   │   ├── NDArrayException.php
│   │   ├── ShapeException.php
│   │   ├── DTypeException.php
│   │   ├── IndexException.php
│   │   └── BroadcastException.php
│   ├── DType.php                # Data type constants
│   ├── Random.php               # Random number generation
│   ├── LinAlg.php               # Linear algebra operations
│   └── Iterator/
│       └── NDIterator.php       # Array iterator
│
├── rust/                         # Rust source code
│   ├── Cargo.toml
│   ├── Cargo.lock
│   ├── build.rs                 # Build script
│   ├── cbindgen.toml            # C header generation config
│   │
│   ├── src/
│   │   ├── lib.rs               # FFI exports
│   │   ├── ndarray_wrapper.rs   # NDArray wrapper
│   │   ├── ffi/
│   │   │   ├── mod.rs
│   │   │   ├── array.rs         # Array FFI functions
│   │   │   ├── operations.rs    # Operation FFI functions
│   │   │   ├── linalg.rs        # Linear algebra FFI
│   │   │   └── error.rs         # Error handling
│   │   ├── memory.rs            # Memory management
│   │   ├── dtype.rs             # Data type handling
│   │   └── utils.rs
│   │
│   └── tests/
│       └── integration_tests.rs
│
├── tests/                        # PHP tests
│   ├── Unit/
│   │   ├── NDArrayTest.php
│   │   ├── ShapeTest.php
│   │   ├── OperationsTest.php
│   │   └── LinAlgTest.php
│   ├── Integration/
│   │   └── FullWorkflowTest.php
│   └── Benchmark/
│       └── PerformanceTest.php
│
├── examples/                     # Example code
│   ├── basic_usage.php
│   ├── linear_algebra.php
│   ├── broadcasting.php
│   └── advanced_indexing.php
│
├── docs/                         # Documentation
│   ├── installation.md
│   ├── quickstart.md
│   ├── api-reference.md
│   └── performance.md
│
├── lib/                          # Compiled libraries (gitignored)
│   ├── libphpndarray.so         # Linux
│   ├── libphpndarray.dylib      # macOS
│   └── phpndarray.dll           # Windows
│
└── scripts/                      # Build/utility scripts
    ├── build.sh                 # Build Rust library
    ├── install.sh               # Install dependencies
    └── test.sh                  # Run all tests
```

---

## 3. FFI Architecture

### 3.1 C-Compatible Interface

**Rust FFI Module** (`rust/src/lib.rs`):

```rust
// Export C-compatible functions
#[no_mangle]
pub extern "C" fn ndarray_create(
    data: *const f64,
    len: usize,
    shape: *const usize,
    ndim: usize,
    dtype: u8,
) -> *mut OpaqueNDArray {
    // Implementation
}

#[no_mangle]
pub extern "C" fn ndarray_destroy(ptr: *mut OpaqueNDArray) {
    // Implementation
}

// Opaque pointer type for FFI
#[repr(C)]
pub struct OpaqueNDArray {
    _private: [u8; 0],
}
```

**Auto-generated C Header** (`lib/phpndarray.h`):

```c
// Generated by cbindgen
typedef struct OpaqueNDArray OpaqueNDArray;

OpaqueNDArray* ndarray_create(
    const double* data,
    size_t len,
    const size_t* shape,
    size_t ndim,
    uint8_t dtype
);

void ndarray_destroy(OpaqueNDArray* ptr);

double ndarray_get_item(OpaqueNDArray* ptr, const size_t* indices, size_t ndim);

// ... more functions
```

### 3.2 FFI Manager (PHP)

**File**: `src/FFI/FFIInterface.php`

```php
<?php

namespace PHPNDArray\FFI;

use FFI;

class FFIInterface
{
    private static ?FFI $ffi = null;
    private static ?string $libraryPath = null;

    /**
     * Initialize FFI with the Rust library
     */
    public static function init(?string $libraryPath = null): void
    {
        if (self::$ffi !== null) {
            return; // Already initialized
        }

        self::$libraryPath = $libraryPath ?? self::findLibrary();
        
        $headerPath = __DIR__ . '/../../lib/phpndarray.h';
        
        if (!file_exists($headerPath)) {
            throw new \RuntimeException(
                "Header file not found: $headerPath. Did you build the Rust library?"
            );
        }

        if (!file_exists(self::$libraryPath)) {
            throw new \RuntimeException(
                "Library not found: " . self::$libraryPath
            );
        }

        self::$ffi = FFI::cdef(
            file_get_contents($headerPath),
            self::$libraryPath
        );
    }

    /**
     * Get FFI instance
     */
    public static function getInstance(): FFI
    {
        if (self::$ffi === null) {
            self::init();
        }
        return self::$ffi;
    }

    /**
     * Find the library file based on platform
     */
    private static function findLibrary(): string
    {
        $baseDir = __DIR__ . '/../../lib/';
        
        if (PHP_OS_FAMILY === 'Windows') {
            return $baseDir . 'phpndarray.dll';
        } elseif (PHP_OS_FAMILY === 'Darwin') {
            return $baseDir . 'libphpndarray.dylib';
        } else {
            return $baseDir . 'libphpndarray.so';
        }
    }

    /**
     * Create a CData array from PHP array
     */
    public static function createCArray(string $type, array $data): \FFI\CData
    {
        $ffi = self::getInstance();
        $count = count($data);
        $cArray = $ffi->new("{$type}[{$count}]");
        
        foreach ($data as $i => $value) {
            $cArray[$i] = $value;
        }
        
        return $cArray;
    }
}
```

### 3.3 Data Type Mapping

**File**: `src/DType.php`

```php
<?php

namespace PHPNDArray;

enum DType: int
{
    case INT8 = 0;
    case INT16 = 1;
    case INT32 = 2;
    case INT64 = 3;
    case UINT8 = 4;
    case UINT16 = 5;
    case UINT32 = 6;
    case UINT64 = 7;
    case FLOAT32 = 8;
    case FLOAT64 = 9;
    case BOOL = 10;

    /**
     * Get FFI type string
     */
    public function ffiType(): string
    {
        return match($this) {
            self::INT8 => 'int8_t',
            self::INT16 => 'int16_t',
            self::INT32 => 'int32_t',
            self::INT64 => 'int64_t',
            self::UINT8 => 'uint8_t',
            self::UINT16 => 'uint16_t',
            self::UINT32 => 'uint32_t',
            self::UINT64 => 'uint64_t',
            self::FLOAT32 => 'float',
            self::FLOAT64 => 'double',
            self::BOOL => 'bool',
        };
    }

    /**
     * Get item size in bytes
     */
    public function itemSize(): int
    {
        return match($this) {
            self::INT8, self::UINT8, self::BOOL => 1,
            self::INT16, self::UINT16 => 2,
            self::INT32, self::UINT32, self::FLOAT32 => 4,
            self::INT64, self::UINT64, self::FLOAT64 => 8,
        };
    }

    /**
     * Infer dtype from PHP value
     */
    public static function infer(mixed $value): self
    {
        if (is_bool($value)) {
            return self::BOOL;
        } elseif (is_int($value)) {
            return self::INT64;
        } elseif (is_float($value)) {
            return self::FLOAT64;
        }
        
        throw new \InvalidArgumentException("Cannot infer dtype from value");
    }
}
```

---

## 4. PHP API Surface

### 4.1 Core NDArray Class

**File**: `src/NDArray.php`

```php
<?php

namespace PHPNDArray;

use PHPNDArray\FFI\FFIInterface;
use PHPNDArray\Exceptions\ShapeException;
use PHPNDArray\Exceptions\DTypeException;
use FFI\CData;

class NDArray implements \ArrayAccess, \Iterator, \Countable
{
    /**
     * Opaque pointer to Rust NDArray
     */
    private CData $handle;

    /**
     * Shape of the array
     */
    private array $shape;

    /**
     * Data type
     */
    private DType $dtype;

    /**
     * Number of dimensions
     */
    private int $ndim;

    /**
     * Total number of elements
     */
    private int $size;

    /**
     * Iterator position
     */
    private int $iteratorPosition = 0;

    /**
     * Private constructor - use factory methods
     */
    private function __construct(CData $handle, array $shape, DType $dtype)
    {
        $this->handle = $handle;
        $this->shape = $shape;
        $this->dtype = $dtype;
        $this->ndim = count($shape);
        $this->size = array_product($shape) ?: 0;
    }

    /**
     * Destructor - cleanup Rust memory
     */
    public function __destruct()
    {
        if (isset($this->handle)) {
            $ffi = FFIInterface::getInstance();
            $ffi->ndarray_destroy($this->handle);
        }
    }

    // ==================== Factory Methods ====================

    /**
     * Create array from PHP array
     * 
     * @param array $data Nested PHP array
     * @param DType|null $dtype Data type (auto-inferred if null)
     * @return self
     */
    public static function array(array $data, ?DType $dtype = null): self
    {
        // Infer shape
        $shape = self::inferShape($data);
        
        // Flatten data
        $flatData = self::flattenArray($data);
        
        // Infer dtype if not provided
        if ($dtype === null) {
            $dtype = DType::infer($flatData[0] ?? 0);
        }

        // Create C array
        $ffi = FFIInterface::getInstance();
        $cData = FFIInterface::createCArray($dtype->ffiType(), $flatData);
        $cShape = FFIInterface::createCArray('size_t', $shape);

        // Call Rust
        $handle = $ffi->ndarray_create(
            $cData,
            count($flatData),
            $cShape,
            count($shape),
            $dtype->value
        );

        return new self($handle, $shape, $dtype);
    }

    /**
     * Create array of zeros
     */
    public static function zeros(array $shape, DType $dtype = DType::FLOAT64): self
    {
        $ffi = FFIInterface::getInstance();
        $cShape = FFIInterface::createCArray('size_t', $shape);
        
        $handle = $ffi->ndarray_zeros(
            $cShape,
            count($shape),
            $dtype->value
        );

        return new self($handle, $shape, $dtype);
    }

    /**
     * Create array of ones
     */
    public static function ones(array $shape, DType $dtype = DType::FLOAT64): self
    {
        $ffi = FFIInterface::getInstance();
        $cShape = FFIInterface::createCArray('size_t', $shape);
        
        $handle = $ffi->ndarray_ones(
            $cShape,
            count($shape),
            $dtype->value
        );

        return new self($handle, $shape, $dtype);
    }

    /**
     * Create array filled with value
     */
    public static function full(array $shape, mixed $fillValue, ?DType $dtype = null): self
    {
        $dtype ??= DType::infer($fillValue);
        $ffi = FFIInterface::getInstance();
        $cShape = FFIInterface::createCArray('size_t', $shape);
        
        $handle = $ffi->ndarray_full(
            $cShape,
            count($shape),
            $fillValue,
            $dtype->value
        );

        return new self($handle, $shape, $dtype);
    }

    /**
     * Create identity matrix
     */
    public static function eye(int $n, ?int $m = null, int $k = 0, DType $dtype = DType::FLOAT64): self
    {
        $m ??= $n;
        $ffi = FFIInterface::getInstance();
        
        $handle = $ffi->ndarray_eye($n, $m, $k, $dtype->value);

        return new self($handle, [$n, $m], $dtype);
    }

    /**
     * Create evenly spaced values
     */
    public static function arange(
        mixed $start,
        mixed $stop = null,
        mixed $step = 1,
        ?DType $dtype = null
    ): self {
        if ($stop === null) {
            $stop = $start;
            $start = 0;
        }

        $dtype ??= DType::infer($start);
        $ffi = FFIInterface::getInstance();
        
        $handle = $ffi->ndarray_arange(
            (float)$start,
            (float)$stop,
            (float)$step,
            $dtype->value
        );

        $size = (int)ceil(($stop - $start) / $step);
        return new self($handle, [$size], $dtype);
    }

    /**
     * Create linearly spaced values
     */
    public static function linspace(
        float $start,
        float $stop,
        int $num = 50,
        bool $endpoint = true,
        DType $dtype = DType::FLOAT64
    ): self {
        $ffi = FFIInterface::getInstance();
        
        $handle = $ffi->ndarray_linspace(
            $start,
            $stop,
            $num,
            $endpoint,
            $dtype->value
        );

        return new self($handle, [$num], $dtype);
    }

    // ==================== Properties ====================

    /**
     * Get shape
     */
    public function shape(): array
    {
        return $this->shape;
    }

    /**
     * Get number of dimensions
     */
    public function ndim(): int
    {
        return $this->ndim;
    }

    /**
     * Get total number of elements
     */
    public function size(): int
    {
        return $this->size;
    }

    /**
     * Get data type
     */
    public function dtype(): DType
    {
        return $this->dtype;
    }

    /**
     * Get item size in bytes
     */
    public function itemsize(): int
    {
        return $this->dtype->itemSize();
    }

    /**
     * Get total bytes
     */
    public function nbytes(): int
    {
        return $this->size * $this->itemsize();
    }

    /**
     * Get strides
     */
    public function strides(): array
    {
        $ffi = FFIInterface::getInstance();
        $cStrides = $ffi->ndarray_strides($this->handle, $this->ndim);
        
        $strides = [];
        for ($i = 0; $i < $this->ndim; $i++) {
            $strides[] = $cStrides[$i];
        }
        
        return $strides;
    }

    /**
     * Check if C-contiguous
     */
    public function isContiguous(): bool
    {
        $ffi = FFIInterface::getInstance();
        return $ffi->ndarray_is_contiguous($this->handle);
    }

    /**
     * Transpose property (for 2D arrays)
     */
    public function __get(string $name): mixed
    {
        if ($name === 'T') {
            return $this->transpose();
        }
        
        throw new \InvalidArgumentException("Property $name does not exist");
    }

    // ==================== Indexing ====================

    /**
     * Get item at indices
     */
    public function get(array $indices): mixed
    {
        if (count($indices) !== $this->ndim) {
            throw new IndexException(
                "Expected {$this->ndim} indices, got " . count($indices)
            );
        }

        $ffi = FFIInterface::getInstance();
        $cIndices = FFIInterface::createCArray('size_t', $indices);
        
        return $ffi->ndarray_get_item($this->handle, $cIndices, $this->ndim);
    }

    /**
     * Set item at indices
     */
    public function set(array $indices, mixed $value): void
    {
        if (count($indices) !== $this->ndim) {
            throw new IndexException(
                "Expected {$this->ndim} indices, got " . count($indices)
            );
        }

        $ffi = FFIInterface::getInstance();
        $cIndices = FFIInterface::createCArray('size_t', $indices);
        
        $ffi->ndarray_set_item($this->handle, $cIndices, $this->ndim, $value);
    }

    /**
     * Slice array
     */
    public function slice(array $slices): self
    {
        // Parse slice notation
        $parsedSlices = $this->parseSlices($slices);
        
        $ffi = FFIInterface::getInstance();
        
        // Create slice parameters
        $starts = [];
        $stops = [];
        $steps = [];
        
        foreach ($parsedSlices as $slice) {
            $starts[] = $slice['start'];
            $stops[] = $slice['stop'];
            $steps[] = $slice['step'];
        }
        
        $cStarts = FFIInterface::createCArray('int64_t', $starts);
        $cStops = FFIInterface::createCArray('int64_t', $stops);
        $cSteps = FFIInterface::createCArray('int64_t', $steps);
        
        $handle = $ffi->ndarray_slice(
            $this->handle,
            $cStarts,
            $cStops,
            $cSteps,
            count($slices)
        );
        
        // Calculate new shape
        $newShape = $this->calculateSlicedShape($parsedSlices);
        
        return new self($handle, $newShape, $this->dtype);
    }

    // ==================== Arithmetic Operations ====================

    /**
     * Addition
     */
    public function add(NDArray|int|float $other): self
    {
        $ffi = FFIInterface::getInstance();
        
        if ($other instanceof NDArray) {
            $handle = $ffi->ndarray_add($this->handle, $other->handle);
            $shape = $this->broadcastShape($this->shape, $other->shape);
        } else {
            $handle = $ffi->ndarray_add_scalar($this->handle, (float)$other);
            $shape = $this->shape;
        }
        
        return new self($handle, $shape, $this->dtype);
    }

    /**
     * Subtraction
     */
    public function subtract(NDArray|int|float $other): self
    {
        $ffi = FFIInterface::getInstance();
        
        if ($other instanceof NDArray) {
            $handle = $ffi->ndarray_subtract($this->handle, $other->handle);
            $shape = $this->broadcastShape($this->shape, $other->shape);
        } else {
            $handle = $ffi->ndarray_subtract_scalar($this->handle, (float)$other);
            $shape = $this->shape;
        }
        
        return new self($handle, $shape, $this->dtype);
    }

    /**
     * Multiplication
     */
    public function multiply(NDArray|int|float $other): self
    {
        $ffi = FFIInterface::getInstance();
        
        if ($other instanceof NDArray) {
            $handle = $ffi->ndarray_multiply($this->handle, $other->handle);
            $shape = $this->broadcastShape($this->shape, $other->shape);
        } else {
            $handle = $ffi->ndarray_multiply_scalar($this->handle, (float)$other);
            $shape = $this->shape;
        }
        
        return new self($handle, $shape, $this->dtype);
    }

    /**
     * Division
     */
    public function divide(NDArray|int|float $other): self
    {
        $ffi = FFIInterface::getInstance();
        
        if ($other instanceof NDArray) {
            $handle = $ffi->ndarray_divide($this->handle, $other->handle);
            $shape = $this->broadcastShape($this->shape, $other->shape);
        } else {
            $handle = $ffi->ndarray_divide_scalar($this->handle, (float)$other);
            $shape = $this->shape;
        }
        
        return new self($handle, $shape, $this->dtype);
    }

    /**
     * Power
     */
    public function power(NDArray|int|float $other): self
    {
        $ffi = FFIInterface::getInstance();
        
        if ($other instanceof NDArray) {
            $handle = $ffi->ndarray_power($this->handle, $other->handle);
            $shape = $this->broadcastShape($this->shape, $other->shape);
        } else {
            $handle = $ffi->ndarray_power_scalar($this->handle, (float)$other);
            $shape = $this->shape;
        }
        
        return new self($handle, $shape, $this->dtype);
    }

    // ==================== Mathematical Functions ====================

    /**
     * Absolute value
     */
    public function abs(): self
    {
        $ffi = FFIInterface::getInstance();
        $handle = $ffi->ndarray_abs($this->handle);
        return new self($handle, $this->shape, $this->dtype);
    }

    /**
     * Square root
     */
    public function sqrt(): self
    {
        $ffi = FFIInterface::getInstance();
        $handle = $ffi->ndarray_sqrt($this->handle);
        return new self($handle, $this->shape, $this->dtype);
    }

    /**
     * Exponential
     */
    public function exp(): self
    {
        $ffi = FFIInterface::getInstance();
        $handle = $ffi->ndarray_exp($this->handle);
        return new self($handle, $this->shape, $this->dtype);
    }

    /**
     * Natural logarithm
     */
    public function log(): self
    {
        $ffi = FFIInterface::getInstance();
        $handle = $ffi->ndarray_log($this->handle);
        return new self($handle, $this->shape, $this->dtype);
    }

    /**
     * Sine
     */
    public function sin(): self
    {
        $ffi = FFIInterface::getInstance();
        $handle = $ffi->ndarray_sin($this->handle);
        return new self($handle, $this->shape, $this->dtype);
    }

    /**
     * Cosine
     */
    public function cos(): self
    {
        $ffi = FFIInterface::getInstance();
        $handle = $ffi->ndarray_cos($this->handle);
        return new self($handle, $this->shape, $this->dtype);
    }

    // ==================== Reduction Operations ====================

    /**
     * Sum of array elements
     */
    public function sum(?int $axis = null, bool $keepdims = false): NDArray|float
    {
        $ffi = FFIInterface::getInstance();
        
        if ($axis === null) {
            // Sum all elements
            return $ffi->ndarray_sum_all($this->handle);
        }
        
        $handle = $ffi->ndarray_sum($this->handle, $axis, $keepdims);
        $newShape = $this->reduceShape($axis, $keepdims);
        
        return new self($handle, $newShape, $this->dtype);
    }

    /**
     * Mean of array elements
     */
    public function mean(?int $axis = null, bool $keepdims = false): NDArray|float
    {
        $ffi = FFIInterface::getInstance();
        
        if ($axis === null) {
            return $ffi->ndarray_mean_all($this->handle);
        }
        
        $handle = $ffi->ndarray_mean($this->handle, $axis, $keepdims);
        $newShape = $this->reduceShape($axis, $keepdims);
        
        return new self($handle, $newShape, DType::FLOAT64);
    }

    /**
     * Standard deviation
     */
    public function std(?int $axis = null, int $ddof = 0, bool $keepdims = false): NDArray|float
    {
        $ffi = FFIInterface::getInstance();
        
        if ($axis === null) {
            return $ffi->ndarray_std_all($this->handle, $ddof);
        }
        
        $handle = $ffi->ndarray_std($this->handle, $axis, $ddof, $keepdims);
        $newShape = $this->reduceShape($axis, $keepdims);
        
        return new self($handle, $newShape, DType::FLOAT64);
    }

    /**
     * Minimum value
     */
    public function min(?int $axis = null, bool $keepdims = false): NDArray|float
    {
        $ffi = FFIInterface::getInstance();
        
        if ($axis === null) {
            return $ffi->ndarray_min_all($this->handle);
        }
        
        $handle = $ffi->ndarray_min($this->handle, $axis, $keepdims);
        $newShape = $this->reduceShape($axis, $keepdims);
        
        return new self($handle, $newShape, $this->dtype);
    }

    /**
     * Maximum value
     */
    public function max(?int $axis = null, bool $keepdims = false): NDArray|float
    {
        $ffi = FFIInterface::getInstance();
        
        if ($axis === null) {
            return $ffi->ndarray_max_all($this->handle);
        }
        
        $handle = $ffi->ndarray_max($this->handle, $axis, $keepdims);
        $newShape = $this->reduceShape($axis, $keepdims);
        
        return new self($handle, $newShape, $this->dtype);
    }

    // ==================== Shape Manipulation ====================

    /**
     * Reshape array
     */
    public function reshape(array $newShape): self
    {
        // Validate shape
        $newSize = array_product($newShape);
        if ($newSize !== $this->size) {
            throw new ShapeException(
                "Cannot reshape array of size {$this->size} into shape " .
                json_encode($newShape)
            );
        }

        $ffi = FFIInterface::getInstance();
        $cShape = FFIInterface::createCArray('size_t', $newShape);
        
        $handle = $ffi->ndarray_reshape($this->handle, $cShape, count($newShape));
        
        return new self($handle, $newShape, $this->dtype);
    }

    /**
     * Flatten array
     */
    public function flatten(): self
    {
        return $this->reshape([$this->size]);
    }

    /**
     * Transpose array
     */
    public function transpose(?array $axes = null): self
    {
        $ffi = FFIInterface::getInstance();
        
        if ($axes === null) {
            $handle = $ffi->ndarray_transpose($this->handle);
            $newShape = array_reverse($this->shape);
        } else {
            $cAxes = FFIInterface::createCArray('size_t', $axes);
            $handle = $ffi->ndarray_transpose_axes(
                $this->handle,
                $cAxes,
                count($axes)
            );
            
            $newShape = [];
            foreach ($axes as $axis) {
                $newShape[] = $this->shape[$axis];
            }
        }
        
        return new self($handle, $newShape, $this->dtype);
    }

    /**
     * Squeeze dimensions
     */
    public function squeeze(?int $axis = null): self
    {
        $ffi = FFIInterface::getInstance();
        
        if ($axis === null) {
            $handle = $ffi->ndarray_squeeze($this->handle);
            $newShape = array_values(array_filter($this->shape, fn($s) => $s !== 1));
        } else {
            if ($this->shape[$axis] !== 1) {
                throw new ShapeException("Cannot squeeze axis $axis (size is not 1)");
            }
            $handle = $ffi->ndarray_squeeze_axis($this->handle, $axis);
            $newShape = $this->shape;
            unset($newShape[$axis]);
            $newShape = array_values($newShape);
        }
        
        return new self($handle, $newShape, $this->dtype);
    }

    // ==================== Linear Algebra ====================

    /**
     * Dot product / matrix multiplication
     */
    public function dot(NDArray $other): self
    {
        $ffi = FFIInterface::getInstance();
        $handle = $ffi->ndarray_dot($this->handle, $other->handle);
        
        // Calculate result shape
        if ($this->ndim === 1 && $other->ndim === 1) {
            // Dot product of vectors
            $newShape = [1];
        } elseif ($this->ndim === 2 && $other->ndim === 2) {
            // Matrix multiplication
            $newShape = [$this->shape[0], $other->shape[1]];
        } elseif ($this->ndim === 2 && $other->ndim === 1) {
            // Matrix-vector multiplication
            $newShape = [$this->shape[0]];
        } else {
            // General case
            $newShape = [$this->shape[0], $other->shape[-1] ?? 1];
        }
        
        return new self($handle, $newShape, $this->dtype);
    }

    /**
     * Matrix multiplication (alias for dot)
     */
    public function matmul(NDArray $other): self
    {
        return $this->dot($other);
    }

    // ==================== Type Conversion ====================

    /**
     * Convert to PHP array
     */
    public function toArray(): array
    {
        $ffi = FFIInterface::getInstance();
        
        // Get flat data
        $flatSize = $this->size;
        $cData = $ffi->ndarray_to_array($this->handle, FFI::addr($flatSize));
        
        // Convert to PHP array
        $flatArray = [];
        for ($i = 0; $i < $flatSize; $i++) {
            $flatArray[] = $cData[$i];
        }
        
        // Reshape to original dimensions
        return $this->unflattenArray($flatArray, $this->shape);
    }

    /**
     * Copy array
     */
    public function copy(): self
    {
        $ffi = FFIInterface::getInstance();
        $handle = $ffi->ndarray_copy($this->handle);
        return new self($handle, $this->shape, $this->dtype);
    }

    /**
     * Convert data type
     */
    public function astype(DType $dtype): self
    {
        $ffi = FFIInterface::getInstance();
        $handle = $ffi->ndarray_astype($this->handle, $dtype->value);
        return new self($handle, $this->shape, $dtype);
    }

    // ==================== ArrayAccess Implementation ====================

    public function offsetExists(mixed $offset): bool
    {
        // For 1D arrays
        if (is_int($offset)) {
            return $offset >= 0 && $offset < $this->shape[0];
        }
        return false;
    }

    public function offsetGet(mixed $offset): mixed
    {
        if ($this->ndim === 1) {
            return $this->get([$offset]);
        } else {
            // Return view of sub-array
            return $this->slice([$offset]);
        }
    }

    public function offsetSet(mixed $offset, mixed $value): void
    {
        if ($this->ndim === 1) {
            $this->set([$offset], $value);
        } else {
            throw new \RuntimeException(
                "Multi-dimensional assignment not yet implemented"
            );
        }
    }

    public function offsetUnset(mixed $offset): void
    {
        throw new \RuntimeException("Cannot unset array elements");
    }

    // ==================== Iterator Implementation ====================

    public function current(): mixed
    {
        return $this->offsetGet($this->iteratorPosition);
    }

    public function key(): int
    {
        return $this->iteratorPosition;
    }

    public function next(): void
    {
        $this->iteratorPosition++;
    }

    public function rewind(): void
    {
        $this->iteratorPosition = 0;
    }

    public function valid(): bool
    {
        return $this->iteratorPosition < ($this->shape[0] ?? 0);
    }

    // ==================== Countable Implementation ====================

    public function count(): int
    {
        return $this->shape[0] ?? 0;
    }

    // ==================== String Representation ====================

    public function __toString(): string
    {
        return $this->formatArray($this->toArray(), 0);
    }

    // ==================== Helper Methods ====================

    /**
     * Infer shape from nested PHP array
     */
    private static function inferShape(array $data): array
    {
        $shape = [];
        $current = $data;
        
        while (is_array($current)) {
            $shape[] = count($current);
            $current = reset($current);
        }
        
        return $shape;
    }

    /**
     * Flatten nested PHP array
     */
    private static function flattenArray(array $data): array
    {
        $result = [];
        
        array_walk_recursive($data, function($value) use (&$result) {
            $result[] = $value;
        });
        
        return $result;
    }

    /**
     * Unflatten array to shape
     */
    private function unflattenArray(array $flat, array $shape): array
    {
        if (count($shape) === 1) {
            return array_slice($flat, 0, $shape[0]);
        }
        
        $result = [];
        $chunkSize = array_product(array_slice($shape, 1));
        
        for ($i = 0; $i < $shape[0]; $i++) {
            $chunk = array_slice($flat, $i * $chunkSize, $chunkSize);
            $result[] = $this->unflattenArray($chunk, array_slice($shape, 1));
        }
        
        return $result;
    }

    /**
     * Calculate broadcasted shape
     */
    private function broadcastShape(array $shape1, array $shape2): array
    {
        // NumPy broadcasting rules
        $ndim = max(count($shape1), count($shape2));
        $shape1 = array_pad(array_reverse($shape1), $ndim, 1);
        $shape2 = array_pad(array_reverse($shape2), $ndim, 1);
        
        $result = [];
        for ($i = 0; $i < $ndim; $i++) {
            if ($shape1[$i] === $shape2[$i]) {
                $result[] = $shape1[$i];
            } elseif ($shape1[$i] === 1) {
                $result[] = $shape2[$i];
            } elseif ($shape2[$i] === 1) {
                $result[] = $shape1[$i];
            } else {
                throw new BroadcastException(
                    "Incompatible shapes for broadcasting"
                );
            }
        }
        
        return array_reverse($result);
    }

    /**
     * Calculate shape after reduction
     */
    private function reduceShape(int $axis, bool $keepdims): array
    {
        if ($keepdims) {
            $shape = $this->shape;
            $shape[$axis] = 1;
            return $shape;
        } else {
            $shape = $this->shape;
            unset($shape[$axis]);
            return array_values($shape);
        }
    }

    /**
     * Parse slice notation
     */
    private function parseSlices(array $slices): array
    {
        $parsed = [];
        
        foreach ($slices as $i => $slice) {
            if (is_int($slice)) {
                $parsed[] = [
                    'start' => $slice,
                    'stop' => $slice + 1,
                    'step' => 1
                ];
            } elseif (is_string($slice)) {
                $parts = explode(':', $slice);
                $parsed[] = [
                    'start' => $parts[0] !== '' ? (int)$parts[0] : 0,
                    'stop' => isset($parts[1]) && $parts[1] !== '' ? 
                              (int)$parts[1] : $this->shape[$i],
                    'step' => $parts[2] ?? 1
                ];
            }
        }
        
        return $parsed;
    }

    /**
     * Calculate shape after slicing
     */
    private function calculateSlicedShape(array $slices): array
    {
        $shape = [];
        
        foreach ($slices as $i => $slice) {
            $size = (int)ceil(($slice['stop'] - $slice['start']) / $slice['step']);
            if ($size > 1 || ($slice['stop'] - $slice['start']) !== 1) {
                $shape[] = $size;
            }
        }
        
        return $shape ?: [1];
    }

    /**
     * Format array for string representation
     */
    private function formatArray(array $data, int $depth): string
    {
        if (!is_array(reset($data))) {
            return '[' . implode(', ', array_map(
                fn($v) => is_float($v) ? sprintf('%.4f', $v) : $v,
                $data
            )) . ']';
        }
        
        $indent = str_repeat(' ', $depth * 2);
        $items = array_map(
            fn($item) => $this->formatArray($item, $depth + 1),
            $data
        );
        
        return "[\n$indent  " . implode(",\n$indent  ", $items) . "\n$indent]";
    }
}
```

### 4.2 Exception Classes

**File**: `src/Exceptions/NDArrayException.php`

```php
<?php

namespace PHPNDArray\Exceptions;

class NDArrayException extends \Exception {}
```

**File**: `src/Exceptions/ShapeException.php`

```php
<?php

namespace PHPNDArray\Exceptions;

class ShapeException extends NDArrayException {}
```

**File**: `src/Exceptions/DTypeException.php`

```php
<?php

namespace PHPNDArray\Exceptions;

class DTypeException extends NDArrayException {}
```

**File**: `src/Exceptions/IndexException.php`

```php
<?php

namespace PHPNDArray\Exceptions;

class IndexException extends NDArrayException {}
```

**File**: `src/Exceptions/BroadcastException.php`

```php
<?php

namespace PHPNDArray\Exceptions;

class BroadcastException extends NDArrayException {}
```

### 4.3 Usage Examples

```php
<?php

use PHPNDArray\NDArray;
use PHPNDArray\DType;

// Create arrays
$a = NDArray::array([[1, 2, 3], [4, 5, 6]]);
$b = NDArray::zeros([3, 3]);
$c = NDArray::linspace(0, 10, 50);

// Arithmetic
$sum = $a->add($b);
$product = $a->multiply(2);

// Indexing
$value = $a->get([0, 1]); // 2
$row = $a[0]; // First row
$slice = $a->slice([':', '1:3']); // All rows, columns 1-2

// Reductions
$total = $a->sum(); // 21
$colMeans = $a->mean(axis: 0); // Mean of each column

// Linear algebra
$x = NDArray::eye(3);
$y = NDArray::ones([3, 1]);
$result = $x->dot($y);

// Iteration
foreach ($a as $row) {
    echo $row . "\n";
}

// Type conversion
$phpArray = $a->toArray();
$float32 = $a->astype(DType::FLOAT32);
```

---

## 5. Rust Implementation

### 5.1 Core Structures

**File**: `rust/src/ndarray_wrapper.rs`

```rust
use ndarray::{Array, ArrayD, ArrayView, ArrayViewMut, IxDyn, Axis};
use std::sync::Arc;
use parking_lot::RwLock;

/// Data type enumeration matching PHP
#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum DType {
    Int8 = 0,
    Int16 = 1,
    Int32 = 2,
    Int64 = 3,
    Uint8 = 4,
    Uint16 = 5,
    Uint32 = 6,
    Uint64 = 7,
    Float32 = 8,
    Float64 = 9,
    Bool = 10,
}

/// Enum to hold different data types
#[derive(Debug, Clone)]
pub enum ArrayData {
    Int8(Arc<RwLock<ArrayD<i8>>>),
    Int16(Arc<RwLock<ArrayD<i16>>>),
    Int32(Arc<RwLock<ArrayD<i32>>>),
    Int64(Arc<RwLock<ArrayD<i64>>>),
    Uint8(Arc<RwLock<ArrayD<u8>>>),
    Uint16(Arc<RwLock<ArrayD<u16>>>),
    Uint32(Arc<RwLock<ArrayD<u32>>>),
    Uint64(Arc<RwLock<ArrayD<u64>>>),
    Float32(Arc<RwLock<ArrayD<f32>>>),
    Float64(Arc<RwLock<ArrayD<f64>>>),
    Bool(Arc<RwLock<ArrayD<bool>>>),
}

/// Main wrapper around ndarray
pub struct NDArrayWrapper {
    pub data: ArrayData,
    pub dtype: DType,
}

impl NDArrayWrapper {
    /// Create new array from raw data
    pub fn from_slice<T: Clone + 'static>(
        data: &[T],
        shape: &[usize],
        dtype: DType,
    ) -> Result<Self, String> {
        let arr = ArrayD::from_shape_vec(IxDyn(shape), data.to_vec())
            .map_err(|e| format!("Shape error: {}", e))?;
        
        let data = match dtype {
            DType::Float64 => {
                // Assuming T is f64 for now
                ArrayData::Float64(Arc::new(RwLock::new(
                    unsafe { std::mem::transmute(arr) }
                )))
            }
            // Handle other types...
            _ => return Err("Unsupported dtype".to_string()),
        };
        
        Ok(Self { data, dtype })
    }

    /// Create zeros array
    pub fn zeros(shape: &[usize], dtype: DType) -> Self {
        match dtype {
            DType::Float64 => {
                let arr = ArrayD::zeros(IxDyn(shape));
                Self {
                    data: ArrayData::Float64(Arc::new(RwLock::new(arr))),
                    dtype,
                }
            }
            DType::Float32 => {
                let arr = ArrayD::zeros(IxDyn(shape));
                Self {
                    data: ArrayData::Float32(Arc::new(RwLock::new(arr))),
                    dtype,
                }
            }
            DType::Int64 => {
                let arr = ArrayD::zeros(IxDyn(shape));
                Self {
                    data: ArrayData::Int64(Arc::new(RwLock::new(arr))),
                    dtype,
                }
            }
            // Handle other types...
            _ => unimplemented!("Dtype not yet implemented"),
        }
    }

    /// Get element at indices
    pub fn get(&self, indices: &[usize]) -> Result<f64, String> {
        match &self.data {
            ArrayData::Float64(arr) => {
                let arr = arr.read();
                let idx = IxDyn(indices);
                arr.get(idx)
                    .copied()
                    .ok_or_else(|| "Index out of bounds".to_string())
            }
            // Handle other types...
            _ => Err("Unsupported dtype".to_string()),
        }
    }

    /// Set element at indices
    pub fn set(&mut self, indices: &[usize], value: f64) -> Result<(), String> {
        match &mut self.data {
            ArrayData::Float64(arr) => {
                let mut arr = arr.write();
                let idx = IxDyn(indices);
                if let Some(elem) = arr.get_mut(idx) {
                    *elem = value;
                    Ok(())
                } else {
                    Err("Index out of bounds".to_string())
                }
            }
            // Handle other types...
            _ => Err("Unsupported dtype".to_string()),
        }
    }

    /// Element-wise addition
    pub fn add(&self, other: &Self) -> Result<Self, String> {
        match (&self.data, &other.data) {
            (ArrayData::Float64(a), ArrayData::Float64(b)) => {
                let a = a.read();
                let b = b.read();
                let result = &*a + &*b;
                Ok(Self {
                    data: ArrayData::Float64(Arc::new(RwLock::new(result))),
                    dtype: self.dtype,
                })
            }
            // Handle other type combinations...
            _ => Err("Type mismatch".to_string()),
        }
    }

    /// Dot product / matrix multiplication
    pub fn dot(&self, other: &Self) -> Result<Self, String> {
        match (&self.data, &other.data) {
            (ArrayData::Float64(a), ArrayData::Float64(b)) => {
                let a = a.read();
                let b = b.read();
                
                // Use ndarray's dot method
                let result = a.dot(&*b);
                
                Ok(Self {
                    data: ArrayData::Float64(Arc::new(RwLock::new(result))),
                    dtype: self.dtype,
                })
            }
            _ => Err("Type mismatch".to_string()),
        }
    }

    /// Sum reduction
    pub fn sum(&self, axis: Option<usize>) -> Result<Self, String> {
        match &self.data {
            ArrayData::Float64(arr) => {
                let arr = arr.read();
                let result = if let Some(ax) = axis {
                    arr.sum_axis(Axis(ax))
                } else {
                    // Return scalar as 0-d array
                    let sum = arr.sum();
                    ArrayD::from_elem(IxDyn(&[]), sum)
                };
                
                Ok(Self {
                    data: ArrayData::Float64(Arc::new(RwLock::new(result))),
                    dtype: self.dtype,
                })
            }
            _ => Err("Unsupported dtype".to_string()),
        }
    }

    /// Get shape
    pub fn shape(&self) -> Vec<usize> {
        match &self.data {
            ArrayData::Float64(arr) => arr.read().shape().to_vec(),
            ArrayData::Float32(arr) => arr.read().shape().to_vec(),
            ArrayData::Int64(arr) => arr.read().shape().to_vec(),
            // Handle other types...
            _ => vec![],
        }
    }
}
```

### 5.2 FFI Layer

**File**: `rust/src/ffi/array.rs`

```rust
use std::os::raw::c_void;
use std::slice;
use crate::ndarray_wrapper::{NDArrayWrapper, DType};

/// Opaque pointer for FFI
#[repr(C)]
pub struct OpaqueNDArray {
    _private: [u8; 0],
}

impl OpaqueNDArray {
    fn from_wrapper(wrapper: Box<NDArrayWrapper>) -> *mut Self {
        Box::into_raw(wrapper) as *mut Self
    }

    unsafe fn to_wrapper<'a>(ptr: *mut Self) -> &'a mut NDArrayWrapper {
        &mut *(ptr as *mut NDArrayWrapper)
    }

    unsafe fn to_box(ptr: *mut Self) -> Box<NDArrayWrapper> {
        Box::from_raw(ptr as *mut NDArrayWrapper)
    }
}

/// Create array from data
#[no_mangle]
pub extern "C" fn ndarray_create(
    data: *const f64,
    len: usize,
    shape: *const usize,
    ndim: usize,
    dtype: u8,
) -> *mut OpaqueNDArray {
    if data.is_null() || shape.is_null() {
        return std::ptr::null_mut();
    }

    let dtype = match dtype {
        8 => DType::Float32,
        9 => DType::Float64,
        _ => return std::ptr::null_mut(),
    };

    let data_slice = unsafe { slice::from_raw_parts(data, len) };
    let shape_slice = unsafe { slice::from_raw_parts(shape, ndim) };

    match NDArrayWrapper::from_slice(data_slice, shape_slice, dtype) {
        Ok(wrapper) => OpaqueNDArray::from_wrapper(Box::new(wrapper)),
        Err(_) => std::ptr::null_mut(),
    }
}

/// Create zeros array
#[no_mangle]
pub extern "C" fn ndarray_zeros(
    shape: *const usize,
    ndim: usize,
    dtype: u8,
) -> *mut OpaqueNDArray {
    if shape.is_null() {
        return std::ptr::null_mut();
    }

    let dtype = match dtype {
        8 => DType::Float32,
        9 => DType::Float64,
        2 => DType::Int32,
        3 => DType::Int64,
        _ => return std::ptr::null_mut(),
    };

    let shape_slice = unsafe { slice::from_raw_parts(shape, ndim) };
    let wrapper = NDArrayWrapper::zeros(shape_slice, dtype);
    
    OpaqueNDArray::from_wrapper(Box::new(wrapper))
}

/// Destroy array
#[no_mangle]
pub extern "C" fn ndarray_destroy(ptr: *mut OpaqueNDArray) {
    if !ptr.is_null() {
        unsafe {
            let _ = OpaqueNDArray::to_box(ptr);
        }
    }
}

/// Get item
#[no_mangle]
pub extern "C" fn ndarray_get_item(
    ptr: *mut OpaqueNDArray,
    indices: *const usize,
    ndim: usize,
) -> f64 {
    if ptr.is_null() || indices.is_null() {
        return 0.0;
    }

    let wrapper = unsafe { OpaqueNDArray::to_wrapper(ptr) };
    let indices_slice = unsafe { slice::from_raw_parts(indices, ndim) };

    wrapper.get(indices_slice).unwrap_or(0.0)
}

/// Set item
#[no_mangle]
pub extern "C" fn ndarray_set_item(
    ptr: *mut OpaqueNDArray,
    indices: *const usize,
    ndim: usize,
    value: f64,
) -> bool {
    if ptr.is_null() || indices.is_null() {
        return false;
    }

    let wrapper = unsafe { OpaqueNDArray::to_wrapper(ptr) };
    let indices_slice = unsafe { slice::from_raw_parts(indices, ndim) };

    wrapper.set(indices_slice, value).is_ok()
}

/// Add arrays
#[no_mangle]
pub extern "C" fn ndarray_add(
    a: *mut OpaqueNDArray,
    b: *mut OpaqueNDArray,
) -> *mut OpaqueNDArray {
    if a.is_null() || b.is_null() {
        return std::ptr::null_mut();
    }

    let a_wrapper = unsafe { OpaqueNDArray::to_wrapper(a) };
    let b_wrapper = unsafe { OpaqueNDArray::to_wrapper(b) };

    match a_wrapper.add(b_wrapper) {
        Ok(result) => OpaqueNDArray::from_wrapper(Box::new(result)),
        Err(_) => std::ptr::null_mut(),
    }
}

/// Get shape
#[no_mangle]
pub extern "C" fn ndarray_get_shape(
    ptr: *mut OpaqueNDArray,
    out_shape: *mut usize,
    max_ndim: usize,
) -> usize {
    if ptr.is_null() || out_shape.is_null() {
        return 0;
    }

    let wrapper = unsafe { OpaqueNDArray::to_wrapper(ptr) };
    let shape = wrapper.shape();
    let ndim = shape.len().min(max_ndim);

    let out_slice = unsafe { slice::from_raw_parts_mut(out_shape, ndim) };
    out_slice.copy_from_slice(&shape[..ndim]);

    ndim
}
```

### 5.3 BLAS Integration (Optional)

**File**: `rust/Cargo.toml` (excerpt)

```toml
[package]
name = "phpndarray"
version = "0.1.0"
edition = "2021"

[lib]
name = "phpndarray"
crate-type = ["cdylib"]

[dependencies]
ndarray = { version = "0.15", features = ["blas"] }
# Optional BLAS backends
openblas-src = { version = "0.10", optional = true }
blas-src = { version = "0.9", optional = true }
parking_lot = "0.12"

[features]
default = []
openblas = ["ndarray/blas", "openblas-src"]
blas = ["ndarray/blas", "blas-src"]

[build-dependencies]
cbindgen = "0.26"
```

**File**: `rust/build.rs`

```rust
use std::env;
use std::path::PathBuf;

fn main() {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let output_file = PathBuf::from(&crate_dir)
        .join("..")
        .join("lib")
        .join("phpndarray.h");

    cbindgen::Builder::new()
        .with_crate(crate_dir)
        .with_language(cbindgen::Language::C)
        .generate()
        .expect("Unable to generate bindings")
        .write_to_file(output_file);
}
```

---

## 6. Memory Management Strategy

### 6.1 Reference Counting

**Concept**: Use Rust's `Arc<RwLock<>>` for shared ownership.

```rust
// In NDArrayWrapper
pub struct NDArrayWrapper {
    pub data: Arc<RwLock<ArrayD<f64>>>, // Shared, thread-safe
    pub dtype: DType,
}

impl Clone for NDArrayWrapper {
    fn clone(&self) -> Self {
        Self {
            data: Arc::clone(&self.data), // Increment ref count
            dtype: self.dtype,
        }
    }
}
```

**PHP Side**: Hold opaque pointer, cleanup in `__destruct()`.

### 6.2 View Handling

**Strategy**: Views share the same `Arc` but with different metadata.

```rust
pub struct NDArrayView {
    data: Arc<RwLock<ArrayD<f64>>>,
    view_indices: Vec<SliceInfo>, // Slice metadata
}

impl NDArrayView {
    pub fn create_view(parent: &NDArrayWrapper, slices: &[Slice]) -> Self {
        Self {
            data: Arc::clone(&parent.data),
            view_indices: slices.to_vec(),
        }
    }
}
```

### 6.3 Error Propagation

**Rust Panics → PHP Exceptions**:

```rust
use std::panic;

#[no_mangle]
pub extern "C" fn ndarray_safe_operation(
    ptr: *mut OpaqueNDArray
) -> *mut ErrorResult {
    let result = panic::catch_unwind(|| {
        // Potentially panicking operation
        unsafe { OpaqueNDArray::to_wrapper(ptr) }.some_operation()
    });

    match result {
        Ok(val) => create_success_result(val),
        Err(e) => create_error_result(format!("{:?}", e)),
    }
}
```

**PHP Side**:

```php
$result = $ffi->ndarray_safe_operation($this->handle);
if ($result->is_error) {
    throw new NDArrayException($result->error_message);
}
```

---

## 7. Build System

### 7.1 Build Scripts

**File**: `scripts/build.sh`

```bash
#!/bin/bash
set -e

echo "Building Rust library..."

cd rust

# Build for release
cargo build --release

# Copy library to lib directory
cd ..
mkdir -p lib

if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    cp rust/target/release/libphpndarray.so lib/
elif [[ "$OSTYPE" == "darwin"* ]]; then
    cp rust/target/release/libphpndarray.dylib lib/
elif [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "win32" ]]; then
    cp rust/target/release/phpndarray.dll lib/
fi

echo "Build complete!"
echo "Library location: lib/"
```

### 7.2 Composer Configuration

**File**: `composer.json`

```json
{
  "name": "yourvendor/phpndarray",
  "description": "High-performance N-dimensional arrays for PHP, powered by Rust",
  "type": "library",
  "license": "MIT",
  "authors": [
    {
      "name": "Your Name",
      "email": "you@example.com"
    }
  ],
  "require": {
    "php": "^8.1",
    "ext-ffi": "*"
  },
  "require-dev": {
    "phpunit/phpunit": "^10.0"
  },
  "autoload": {
    "psr-4": {
      "PHPNDArray\\": "src/"
    }
  },
  "autoload-dev": {
    "psr-4": {
      "PHPNDArray\\Tests\\": "tests/"
    }
  },
  "scripts": {
    "build": "bash scripts/build.sh",
    "test": "phpunit"
  }
}
```

---

## 8. Development Workflow

### 8.1 Initial Setup

```bash
# Clone repository
git clone https://github.com/yourvendor/phpndarray
cd phpndarray

# Install PHP dependencies
composer install

# Build Rust library
./scripts/build.sh

# Run tests
composer test
```

### 8.2 Development Cycle

```bash
# 1. Make changes to Rust code
vim rust/src/lib.rs

# 2. Rebuild
./scripts/build.sh

# 3. Test changes
vendor/bin/phpunit tests/Unit/NDArrayTest.php

# 4. Run benchmarks
vendor/bin/phpunit tests/Benchmark/
```

### 8.3 Adding New Features

**Step-by-step**:

1. **Add Rust implementation**:
   - Update `ndarray_wrapper.rs` with new method
   - Add FFI export in `ffi/array.rs`
   - Rebuild to generate updated header

2. **Add PHP wrapper**:
   - Add method to `NDArray.php`
   - Call FFI function
   - Handle errors

3. **Write tests**:
   - Unit test in `tests/Unit/`
   - Integration test if needed

4. **Document**:
   - Add PHPDoc
   - Update examples
   - Update README

---

## 9. Testing Strategy

### 9.1 Test Structure

```php
<?php
// tests/Unit/NDArrayTest.php

namespace PHPNDArray\Tests\Unit;

use PHPUnit\Framework\TestCase;
use PHPNDArray\NDArray;

class NDArrayTest extends TestCase
{
    public function testArrayCreation(): void
    {
        $arr = NDArray::array([[1, 2], [3, 4]]);
        
        $this->assertEquals([2, 2], $arr->shape());
        $this->assertEquals(2, $arr->ndim());
        $this->assertEquals(4, $arr->size());
    }

    public function testAddition(): void
    {
        $a = NDArray::ones([2, 2]);
        $b = NDArray::ones([2, 2]);
        $c = $a->add($b);
        
        $this->assertEquals(2.0, $c->get([0, 0]));
    }

    public function testBroadcasting(): void
    {
        $a = NDArray::ones([3, 1]);
        $b = NDArray::array([1, 2, 3]);
        
        $c = $a->add($b);
        $this->assertEquals([3, 3], $c->shape());
    }
}
```

### 9.2 Memory Leak Testing

```php
<?php
// tests/Unit/MemoryTest.php

class MemoryTest extends TestCase
{
    public function testNoMemoryLeak(): void
    {
        $initialMemory = memory_get_usage();
        
        for ($i = 0; $i < 1000; $i++) {
            $arr = NDArray::zeros([100, 100]);
            unset($arr); // Force cleanup
        }
        
        $finalMemory = memory_get_usage();
        $leak = $finalMemory - $initialMemory;
        
        // Allow for some PHP overhead
        $this->assertLessThan(1000000, $leak); // Less than 1MB
    }
}
```

### 9.3 Benchmarking

```php
<?php
// tests/Benchmark/PerformanceTest.php

class PerformanceTest extends TestCase
{
    public function testMatrixMultiplicationPerformance(): void
    {
        $size = 500;
        $a = NDArray::random([$size, $size]);
        $b = NDArray::random([$size, $size]);
        
        $start = microtime(true);
        $c = $a->dot($b);
        $rustTime = microtime(true) - $start;
        
        echo "\nRust implementation: {$rustTime}s\n";
        
        // Compare with pure PHP (if available)
        // Assert performance is significantly better
    }
}
```

---

## 10. Performance Optimization

### 10.1 Batch Operations

**Strategy**: Minimize FFI crossings by batching operations in Rust.

**Example**: Instead of:
```php
// BAD: Many FFI calls
for ($i = 0; $i < $n; $i++) {
    $arr[$i] = $arr[$i] + 1;
}
```

Do:
```php
// GOOD: Single FFI call
$arr = $arr->add(1);
```

### 10.2 SIMD Optimization

**Rust side**: Enable SIMD in `Cargo.toml`:

```toml
[profile.release]
opt-level = 3
lto = true
codegen-units = 1

[target.'cfg(target_arch = "x86_64")']
rustflags = ["-C", "target-cpu=native"]
```

### 10.3 Parallelization

**Use rayon for parallel operations**:

```rust
use rayon::prelude::*;

impl NDArrayWrapper {
    pub fn parallel_map<F>(&self, f: F) -> Self
    where
        F: Fn(f64) -> f64 + Sync + Send,
    {
        match &self.data {
            ArrayData::Float64(arr) => {
                let arr = arr.read();
                let result: Vec<f64> = arr.iter()
                    .par_bridge()
                    .map(|&x| f(x))
                    .collect();
                
                // Create new array from result
                // ...
            }
            _ => unimplemented!(),
        }
    }
}
```

---

## 11. Deployment Checklist

### 11.1 Pre-release

- [ ] All critical tests passing
- [ ] No memory leaks detected
- [ ] Performance benchmarks meet targets
- [ ] Documentation complete
- [ ] Examples working
- [ ] Cross-platform builds successful

### 11.2 Release

- [ ] Tag version in git
- [ ] Build release binaries for all platforms
- [ ] Publish to Packagist
- [ ] Update documentation site
- [ ] Announce release

### 11.3 Post-release

- [ ] Monitor for issues
- [ ] Respond to bug reports
- [ ] Gather performance feedback
- [ ] Plan next iteration

---

This architecture provides a complete technical foundation for building your PHP NDArray library with Rust FFI backend. The design emphasizes performance, safety, and developer experience while maintaining a clean, NumPy-like API surface.

